---
layout:			post
title:			"瑞吉外卖"
subtitle: 		""
author:			"XiaoZaiz"
header-style: 	text
catalog:      	true
tags:
    - Java
    - Spring
    - MyBatis
    - MySQL
---

# 基础
## 一、软件开发整体介绍
### 1. 软件开发流程
- 需求分析：产品原型、需求规格说明书
- 设计：产品文档、UI界面、概要、详细、数据库
- 编码：项目代码、单元测试
- 测试：测试用例、测试报告
- 上线运维：软件环境安装、配置
### 2. 角色分工
- 项目经理：对整个项目负责，任务分配、把控进度
- 产品经理：进行需求调研
- UI设计师：
- 架构师：
- 开发工程师：
- 测试工程师：
- 运维工程师:
### 3. 软件环境
- 开发环境（development）
- 测试环境（testing）
- 生产环境（production）

## 二、瑞吉外卖项目介绍
### 1 项目介绍
### 2. 产品原型展示
### 3. 技术选型
#### 用户层
- H5
- VUE.js
- ElementUI
- 微信小程序
#### 网关层
- Nginx
#### 应用层
- SpringBoot
- Spring MVC
- Spring Session
- Spring
- Swagger
- lombok
#### 数据层
- Mysql
- Mybatis
- Mybatis Plus
- Redis：缓存
#### 工具
- git
- maven
- junit
### 4. 功能架构
- 移动端前台
- 系统管理后台
### 5. 角色
- 后台系统管理员
- 后台系统普通员工
- C端用户

## 三、开发环境搭建
### 1. 数据库搭建（reggie）
- 创建数据库
- 导入表文件（"\1 瑞吉外卖项目\资料\数据模型\db_reggie.sql"）

```java
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(
  "jdbc:mysql://ap-southeast.connect.psdb.cloud/db?sslMode=VERIFY_IDENTITY",
  "b17wn3np85ofvlozhcq1",
  "pscale_pw_2gMkB2szBZKiNt7HILHaay0o1VP4TJeQZl13JF05tSE");
```

```txt
mysql -h ap-southeast.connect.psdb.cloud -u b17wn3np85ofvlozhcq1 -ppscale_pw_2gMkB2szBZKiNt7HILHaay0o1VP4TJeQZl13JF05tSE
```

### 2. 开发环境搭建

- maven项目：`pom.xml`

- 配置：`application.yml`
- 注解：@`Slf4j`（`log.info()`）

- 静态资源：`static`
- 配置：`config`

#### 2.1 pom.xml

jdk：17

依赖：

- **Lombox**
- **Spring Web**
- **MySQL Driver**
- **MyBatis Framework**
- fastjson
- commons-lang
- druid（springboot3暂时无法使用：2023-3-27 23:09）
- mybatis-plus

#### 2.2 application.yml

```xml
server:
  port: 80 # 应用的端口号为 80。
spring:
  application:
    name: reggie # 应用的名字为 Reggie。
  datasource:
    druid: # Druid 连接池配置。通过这个配置项可以设置 MySQL 的连接地址、用户名和密码等参数。
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://ap-southeast.connect.psdb.cloud/db?sslMode=VERIFY_IDENTITY
      username: b17wn3np85ofvlozhcq1
      password: pscale_pw_2gMkB2szBZKiNt7HILHaay0o1VP4TJeQZl13JF05tSE
mybatis-plus:
  configuration:
    # Mybatis-Plus 的配置信息。在这里设置了表名采用的下划线转驼峰命名规则，并且指定了将 Mybatis 的 SQL 日志输出到控制台上。
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      # 在 Mybatis-Plus 中进行主键生成策略的配置。这里配置了 ASSIGN_ID，表示使用手动分配 ID 的方式来生成主键。
      id-type: ASSIGN_ID
```

#### 2.3 @Slf4j

`@Slf4j` 是 Lombok 库提供的注解，它会根据不同的目标平台（如：JavaSE、Android、GWT等）自动选择最合适的日志框架，并在编译时生成对应的日志实现类。具体来说，使用 `@Slf4j` 注解能够自动为一个类添加一个名为 `log` 的 `private static final Logger` 类型的字段，并且该字段可以被用来记录日志。

使用 `@Slf4j` 注解可以大大简化代码中使用日志框架时的一些常规性的操作，比如创建logger实例，手动书写不同日志级别的方法等。该注解在 Spring Boot 等项目中得到了广泛应用，可以有效提高开发效率和代码可读性。

```java
package com.example.demo;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@Slf4j
public class DemoController {
    
    @GetMapping("/hello")
    @ResponseBody
    public String hello() {
        log.info("访问了 /hello 接口");
        return "Hello World!";
    }
}
```

在上述代码中，我使用了 `@Slf4j` 注解为 `DemoController` 类生成了一个名为 `log` 的 Logger 实例，通过调用该实例来记录日志信息。当然，我们还需要在项目中引入 lombok 和 logback 等相关依赖才能使其生效。

#### 2.4 static（静态文件）

- backend
- front

#### 2.5 配置config

### 3. 后台登录和退出

- 页面原型（backend/page/login/login.html）

- 员工实体类（Employee）
- 员工映射类（EmployeeMapper）
- 员工Service接口和实现类（EmployeeService、EmployeeServiceImpl）
- 员工控制类（EmployeeController）
- 通用类（R）

- 过滤器（Filter）或拦截器

#### 3.1 登录页面

```txt
static/backend/page/login/login.html
```



#### 3.2 实体类Employee

```java
@Data
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String name;
    private String passwor
    private String phone;
    private String sex;
    private String idNumber;
    private Integer status
    private LocalDateTime createTime;
    private LocalDateTime updateTime;

    // @TableField 注解是 Mybatis-Plus 框架提供的注解，用于映射实体类属性到数据表中对应的字段及其属性，比如插入时的自动填充策略等。
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;
}
```

##### 瞬态成员变量

非瞬态成员变量是指在一个类中定义的持久化数据成员，其值会被保留并可供多个方法或实例使用，直到它们被显式地修改或者对象被销毁。这种类型的成员变量通常用于存储类的状态信息和属性，例如对象的名称、位置、大小等。相对而言，瞬态成员变量则是临时性的，其值只在方法执行期间存在，并不会保存到对象的状态中。

瞬态成员变量（transient member variable）是Java语言中的一个关键字，用于修饰一个非静态成员变量。被**transient**修饰的成员变量，不会被默认序列化到对象流中。

在上述示例中，我们使用transient关键字修饰了Person类中的age成员变量。这样，在将Person对象序列化到对象流中时，age字段的值将不会被保存。当需要从对象流中反序列化获得Person对象时，age字段的值也将被设为默认值0。

需要注意的是，使用transient关键字修饰成员变量时，只有那些不含有敏感信息或者没有必要序列化的字段才应该使用该修饰符。

##### Serializable

java.io.Serializable是一个标记接口，它用于表示类的实例可以被序列化为字节流并在网络上传输或存储到文件系统中。当类实现Serializable接口时，它表明该类的所有**非瞬态成员变量**都可以被序列化。为了使类能够被正确地序列化，在编写序列化代码时需要注意以下几点：

1. 要求类及其所有非瞬态成员变量都必须是可序列化的。

2. 需要提供一个 **serialVersionUID 静态常量**，用于指示相应类版本的唯一性。

3. 如果类包含对象引用，则需要确保这些对象也是可序列化的。

4. 可以通过实现writeObject()和readObject()方法来自定义对象的序列化和反序列化过程。

5. 可以使用Java序列化API来将对象序列化为字节数组，或从字节数组中反序列化回对象。



下面代码演示了如何**实现Java`对象`的序列化和反序列化**。

在Person类中，age关键字前使用了`transient`修饰符。因此，在序列化时age字段不会被存储。当需要从对象流中反序列化获得Person对象时，age字段的值也将被设为默认值0。

在SerializationDemo类中，首先创建一个Person对象并将其写入文件person.ser中（序列化操作），然后从该文件中读取数据并将其反序列化为一个新的Person对象，最后输出新对象中的姓名和年龄值。

总的来说，由于**Java对象在网络上传输、存储到磁盘等过程中都需要进行序列化操作**，因此这个知识点对于学习Java编程是非常重要的。

```java
import java.io.*;

public class SerializationDemo {

    public static void main(String[] args) {
        // 创建一个Person对象
        Person person = new Person("张三", 25);

        // 将Person对象序列化到文件中
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            oos.writeObject(person);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 从文件中读取Person对象并进行反序列化
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person p = (Person) ois.readObject();
            System.out.println(p.getName() + ", " + p.getAge());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

}

class Person implements Serializable {

    private static final long serialVersionUID = 1L;
    
    private String name;
    private transient int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

}
```

#### 3.3 映射类EmployeeMapper

```java
@Mapper
public interface EmployeeMapper extends BaseMapper<Employee> {
    // 在这段代码中，我们只需在 EmployeeMapper 接口中定义自己需要的方法即可，Mybatis-Plus 框架会帮我们完成其他基本的 SQL 操作。
}
```

这段代码定义了一个 `EmployeeMapper` 接口，该接口继承了 Mybatis-Plus 提供的 `BaseMapper` 接口，并加上了一个注解 `@Mapper`，它将会被 Spring 扫描并注册为一个 Mybatis 映射器(mapper)。

在 Mybatis 中，mapper 用于处理数据的持久层操作。每个 mapper 接口都对应着一个 XML 文件（或注解），其中定义了各种 SQL 语句及其参数映射关系等信息。

其中继承的 BaseMapper 接口是 Mybatis-Plus 框架提供的，它已经封装了常用的 `CRUD` 方法，包括增删改查等功能。通过继承它可以减少开发者编写常见 SQL 的时间和工作量。同时，@Mapper 注解也保证了该接口能够被成功地注册到 Mybatis 的运行环境中，可以用来直接对数据库进行 CRUD 操作。

#### 3.4 Service接口和实现类EmployeeService、EmployeeServiceImpl

MybatisPlus是一个基于Mybatis的ORM框架，提供了一系列简化开发的功能。其中，IService和ServiceImpl是MybatisPlus中用来实现Service层的接口和实现类。

IService是一个顶层接口，定义了一些通用的业务方法，如增、删、改、查等。IService可以让我们在Service层编写代码时更加规范和方便，同时也可以使得不同的Service实现类更加通用和可替换。

ServiceImpl是IService的默认实现类，也是我们常用的Service层实现类。ServiceImpl实现了IService中定义的所有通用方法，并且**根据需要可以添加自定义的业务方法**。通过继承ServiceImpl，我们可以很方便地创建自己的Service层实现类，并且可以在其中使用MybatisPlus提供的一系列便捷的查询、更新、删除等操作。

```java
public interface EmployeeService extends IService<Employee> {
}
```

```java
@Service
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployeeService {
}
```



#### 3.5 通用类R

| 属性            | 说明                           |
| --------------- | ------------------------------ |
| （Integer）code | 编码：1成功，0和其它数字为失败 |
| （String）msg   | 错误信息                       |
| （T）data       | 数据                           |
| （HashMap）map  | 动态数据                       |

这段代码定义了一个泛型类 `R<T>`，其中 `T` 用于表示数据的类型。它有四个成员变量 `code`, `msg`, `data` 和 `map`，分别代表编码、错误信息、数据和动态数据。

类中还定义了三个方法：

- `success(T object)`：表示请求成功时的返回值。该方法接收一个泛型参数 `object` 作为返回的数据，并构造一个 `R<T>` 对象，将数据和编码设置为 1，最后返回该对象。
- `error(String msg)`：表示请求失败时的返回值。该方法接收一个字符串参数 `msg` 作为错误信息，并构造一个 `R` 对象，将错误信息和编码设置为 0，最后返回该对象。
- `add(String key, Object value)`：该方法用于向动态数据中添加一个键值对。它接收两个参数 `key` 和 `value`，将它们存储到 `map` 中，并返回当前对象本身。

通过这些方法的组合，可以方便地构造出包含数据、错误信息以及动态数据的响应对象。

```java
@Data
public class R<T> {

    private Integer code; //编码：1成功，0和其它数字为失败
    private String msg; //错误信息
    private T data; //数据
    private Map map = new HashMap(); //动态数据

    public static <T> R<T> success(T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = 1;
        return r;
    }

    public static <T> R<T> error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }

    public R<T> add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }

}
```

#### 3.6 控制类EmployeeController

```java
@Slf4j
@RestController
@RequestMapping("/employee")
public class EmployeeController {
    @Resource
    private EmployeeService employeeService;

    /**
     * 员工登录
     * @param request 设置session
     * @param employee
     * @return
     */
    @PostMapping("/login")
    public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
        // 密码 md5 处理
        String password = employee.getPassword();
        password = DigestUtils.md5DigestAsHex(password.getBytes());
        // 数据库查询
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        Employee emp = employeeService.getOne(queryWrapper);
        // 检查查询结果
        if(emp == null){
            return R.error("登录失败！");
        }
        // 比对密码
        if(!emp.getPassword().equals(password)){
            return R.error("登录失败！");
        }
        // 查看员工状态
        if(emp.getStatus() == 0){
            return R.error("账号已禁用！");
        }
        // 将员工id存放在Session并返回登录结果
        request.getSession().setAttribute("employee",emp.getId());
        return R.success(emp);
    }

    /**
     * 员工退出
     * @param request
     * @return
     */
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request){
        // 清理Session
        request.getSession().removeAttribute("employee");
        return R.success("退出成功");
    }
}
```



#### 3.7 过滤器Filter

启动类添加`@ServletComponentScan`

```java
@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")
@Slf4j
public class LoginCheckFilter implements Filter {
    // 路径匹配
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpServletResponse response = (HttpServletResponse)servletResponse;
        log.info("拦截到请求：{}",request.getRequestURI());
        // 判断请求是否需要处理
        String requestURI = request.getRequestURI();
        String[] urls = new String[] {
                "/employee/login",
                "/employee/logout",
                // 静态资源
                "/backend/**",
                "/front/**"
        };
        // 处理请求
        boolean check = check(urls,requestURI);
        // 如果不需要处理
        if(check){
            filterChain.doFilter(request,response);
            return;
        }
        // 判断登录状态
        if(request.getSession().getAttribute("employee") != null){
            filterChain.doFilter(request,response);
            return;
        }
        // 未登录处理，向客户端响应未登录数据
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
    }

    // 处理请求判断方法
    public boolean check(String[] urls,String requestURI){
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url, requestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}
```

#### 3.8 数据表employee

```mysql
CREATE TABLE `employee` (
	`id` bigint NOT NULL COMMENT '主键',
	`name` varchar(32) NOT NULL COMMENT '姓名',
	`username` varchar(32) NOT NULL COMMENT '用户名',
	`password` varchar(64) NOT NULL COMMENT '密码',
	`phone` varchar(11) NOT NULL COMMENT '手机号',
	`sex` varchar(2) NOT NULL COMMENT '性别',
	`id_number` varchar(18) NOT NULL COMMENT '身份证号',
	`status` int NOT NULL DEFAULT '1' COMMENT '状态 0:禁用，1:正常',
	`create_time` datetime NOT NULL COMMENT '创建时间',
	`update_time` datetime NOT NULL COMMENT '更新时间',
	`create_user` bigint NOT NULL COMMENT '创建人',
	`update_user` bigint NOT NULL COMMENT '修改人',
	PRIMARY KEY (`id`),
	UNIQUE KEY `idx_username` (`username`)
) ENGINE InnoDB,
  CHARSET utf8mb3,
  COLLATE utf8mb3_bin,
  COMMENT '员工信息';
```



### 4. 新增员工

#### 4.1 页面

员工列表：`static/backend/page/member/list.html`

添加/修改员工：`static/backend/page/member/add.html`

#### 4.2 控制器（EmployeeController）

```java
    @PostMapping
    public R<String> save(HttpServletRequest request, @RequestBody Employee employee){
        log.info("新增员工，员工信息：{}",employee.toString());
        // 设置员工初始密码123456（使用md5加密）
        employee.setPassword((DigestUtils.md5DigestAsHex("123456".getBytes())));
        // 设置员工创建和更新时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());
        // 设置当前登录用户和最后更新用户的id
        Long enpId = (Long)request.getSession().getAttribute("employee");
        employee.setCreateUser(enpId);
        employee.setUpdateUser(enpId);
        // 保存员工信息
        employeeService.save(employee);
        return R.success("新增员工成功！");
    }
```

#### 4.3 全局异常捕获（GlobalExceptionHandler）

避免员工账号重复

```java
@ControllerAdvice(annotations = {RestController.class, Controller.class})
@ResponseBody
@Slf4j
public class GlobalExceptionHandler {
    /**
     * 异常处理方法
     * @param ex
     * @return
     */
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex) {
        log.error(ex.getMessage());
        // 提示异常信息
        if(ex.getMessage().contains("Duplicate entry")){
            String[] split = ex.getMessage().split(" ");
            // split[13]和"Duplicate entry"要根据异常信息选择
            // String msg = "\'" + split[13] + "已存在";
            return R.error("账号重复，请重新输入");
        }
        return R.error("未知错误！");
    }
}
```

### 5. 员工信息分页

#### 5.1 页面

```txt
static/backend/page/member/list.html
```

请求查询参数`page`、`pageSize`和`name`，其中`name`用于查询

#### 5.2 配置MP的分页插件（MybatisPlusConfig）

```java
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```

#### 5.3 控制器（EmployeeController）

```java
    @GetMapping("/page")
    public R<Page> page(int page,int pageSize,String name) {
        log.info("page = {},pageSize = {},name = {}",page,pageSize,name);
        // 构造分页构造器
        Page pageInfo = new Page(page,pageSize);
        // 构造条件构造器
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper();
        // 添加过滤条件
        queryWrapper.like(StringUtils.hasText(name),Employee::getName,name);
        // 添加排序条件
        queryWrapper.orderByDesc(Employee::getUpdateTime);
        // 执行查询
        employeeService.page(pageInfo,queryWrapper);
        return R.success(pageInfo);
    }
```

### 6. 启用/禁用员工账号

#### 6.1 对象映射器JacksonObjectMapper

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

#### 6.2 WebMvcConfig

```java
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/backend/**")
                .addResourceLocations("classpath:/static/backend/");
        registry.addResourceHandler("/front/")
                .addResourceLocations("classpath:/static/front/");
    }

    /**
     * 消息转换器
     * @param converters
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        // 创建消息转换器对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        // 设置对象转换器，底层使用Jackson将Java对象转为json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        // 将消息转换器对象追加到mvc框架的转换器集合中
        converters.add(0,messageConverter);
    }
}
```

#### 6.3 控制器（EmployeeController）

```java
    @PutMapping
    public R<String> update(HttpServletRequest request,@RequestBody Employee employee){
        log.info("修改员工信息");
        // 修改更新时间
        employee.setUpdateTime(LocalDateTime.now());
        // 修改用户
        employee.setUpdateUser((Long) request.getSession().getAttribute("employee"));
        employeeService.updateById(employee);
        return R.success("员工信息修改成功！");
    }
```



### 7. 编辑员工信息

回显员工信息：通过id查询

#### 7.1 控制器（EmployeeController）

```java
    /**
     * 根据id查询员工信息
     * @param id
     * @return
     */
    @GetMapping("/{id}")
    public R<Employee> getEmployeeById(@PathVariable Long id){
        Employee employee = employeeService.getById(id);
        if(employee != null){
            return R.success(employee);
        }
        return R.error("没有查询到对应的员工信息！");
    }                                                                                  
```

### 8. 公共字段自动填充

#### 8.1 @TableField注解

在实体类的属性加上@TableField注解，指定自动填充的策列

```java
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT)
    private Long createUser;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;
```

#### 8.3 ThreadLocal类

Thread的局部变量，线程内有效

常用方法：

- publlic void set(T value)
- public T get()

#### 8.4 BaseContext类

```java
/**
 * 基于ThreadLocal封装工具类，用于保存和获取当前登录用户id
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();
    public static void setCurrentId(Long id){
        threadLocal.set(id);
    }

    public static Long getCurrentId(){
        return threadLocal.get();
    }
}
```

#### 8.5 LoginCheckFilter类

```java
        // 判断登录状态
        if(request.getSession().getAttribute("employee") != null){
            Long empId = (Long) request.getSession().getAttribute("employee");
            BaseContext.setCurrentId(empId);
            filterChain.doFilter(request,response);
            return;
        }
```





#### 8.2 MyMetaObjectHandler类

```java
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("执行插入操作："+metaObject.toString());
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("createUser", BaseContext.getCurrentId());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("执行更新操作："+metaObject.toString());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
}
```

### 9. 新增菜品分类

- 数据表：category
- 实体类：Category
- Mapper接口：CategoryMapper
- 业务层接口：CategoryService
- 业务层实现类：CategoryServiceImpl
- 控制层：CategoryController

#### 9.1 数据表（category）

- id
- type
- name
- sort
- create_time
- update_time
- create_user
- update_user

#### 9.2 实体类（Category）

```java
/**
 * 分类
 */
@Data
public class Category implements Serializable {

    private static final long serialVersionUID = 1L;
    
    private Long id;
    //类型 1 菜品分类 2 套餐分类
    private Integer type;
    //分类名称
    private String name;
    //顺序
    private Integer sort;
    //创建时间
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    //更新时间
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    //创建人
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;
    //修改人
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;
    //是否删除
    private Integer isDeleted;

}
```



####  9.3 Mapper接口：CategoryMapper

```java
@Mapper
public interface CategoryMapper extends BaseMapper<Category> {
}
```



#### 9.4 业务层接口：CategoryService

```java
public interface CategoryService extends IService<Category> {
}
```



#### 9.5 业务层实现类：CategoryServiceImpl

```java
@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
}
```



#### 9.6 控制层：CategoryController

```java
@RestController
@RequestMapping("/category")
@Slf4j
public class CategoryController {
    @Resource
    private CategoryService categoryService;

    /**
     * 新增菜品分类
     * @param category
     * @return
     */
    @PostMapping
    public R<String> save(@RequestBody Category category){
        log.info(""+category.toString());
        categoryService.save(category);
        return R.success("新增分类成功！");
    }
}
```



### 10. 分类信息分页查询

#### 10.1 控制层：CategoryController

如果失败，暂时把实体类的`isDeleted`属性注释掉。

```java
    @GetMapping("/page")
    public R<Page> page(int page, int pageSize){
        log.info("page="+page+"pageSize="+pageSize);
        // 构造分页构造器
        Page<Category> pageInfo = new Page<>(page,pageSize);
        // 添加排序条件
        LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.orderByDesc(Category::getSort);
        // 执行查询
        categoryService.page(pageInfo,queryWrapper);
        log.info(pageInfo+"");
        return R.success(pageInfo);
    }
```

### 11. 删除分类

#### 11.1 控制层：CategoryController

```java
    /**
     * 删除菜品分类
     * @param ids
     * @return
     */
    @DeleteMapping
    public R<String> delete(Long ids){
        // 删除菜品
        categoryService.removeById(ids);
        return R.success("分类信息删除成功！");
    }
```

### 12. 完善删除分类

- 实体类：Dish
- 实体类：Setmeal
- Mapper接口：DishMapper
- Mapper接口：SetmealMapper
- Service接口：DishService
- Service接口：SetmealService
- Service实现类：DishServiceImpl
- Service实现类：SetmealServiceImpl

#### 12.1 实体类：Dish

```java
/**
 菜品
 */
@Data
public class Dish implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;
    //菜品名称
    private String name;
    //菜品分类id
    private Long categoryId;
    //菜品价格
    private BigDecimal price;
    //商品码
    private String code;
    //图片
    private String image;
    //描述信息
    private String description;
    //0 停售 1 起售
    private Integer status;
    //顺序
    private Integer sort;
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;
    //是否删除
    private Integer isDeleted;

}
```



#### 12.2 实体类：Setmeal

```java
/**
 * 套餐
 */
@Data
public class Setmeal implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;
    //分类id
    private Long categoryId;
    //套餐名称
    private String name;
    //套餐价格
    private BigDecimal price;
    //状态 0:停用 1:启用
    private Integer status;
    //编码
    private String code;
    //描述信息
    private String description;
    //图片
    private String image;
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;
    //是否删除
    private Integer isDeleted;
}
```



#### 12.3 Mapper接口：DishMapper

```java
@Mapper
public interface DishMapper extends BaseMapper<Dish> {
}
```

#### 12.4 Mapper接口：SetmealMapper

```java
@Mapper
public interface SetmealMapper extends BaseMapper<Setmeal> {
}
```

#### 12.5 Service接口：DishService

```java
public interface DishService extends IService<Dish> {
}
```

#### 12.6 Service接口：SetmealService

```java
public interface SetmealService extends IService<Setmeal> {
}
```

#### 12.7 Service实现类：DishServiceImpl

```java
@Service
public class DishServiceImpl extends ServiceImpl<DishMapper, Dish> implements DishService {
}
```



#### 12.8 Service实现类：SetmealServiceImpl

```java
@Service
public class SetmealServiceImpl extends ServiceImpl<SetmealMapper, Setmeal> implements SetmealService {
}
```

#### 12.9 CategoryServiceImpl

```java
@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {

    @Resource
    private DishService dishService;
    @Resource
    private SetmealService setmealService;
    /**
     * 根据id删除分类，删除之前需要进行判断
     * @param id
     */
    @Override
    public void remove(Long id) {
        // 查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常
        LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 查询条件
        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);
        int count1 = dishService.count(dishLambdaQueryWrapper);
        if (count1 > 0){
            throw new CustomException("当前分类下关联菜品，不能删除");
        }
        // 查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常
        LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 查询条件
        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);
        int count2 = setmealService.count();
        if (count2 > 0){
            throw new CustomException("当前分类下关联套餐，不能删除");
        }
        // 正常删除分类
        super.removeById(id);
    }
}
```

#### 12.10 自定义业务异常：CustonException

```java
/**
 * 自定义业务异常
 */
public class CustomException extends RuntimeException{
    public CustomException(String message){
        super(message);
    }
}
```

#### 12.11 全局异常处理器：捕获异常：GlobalExceptionHandler

```java
    @ExceptionHandler(CustomException.class)
    public R<String> exceptionHandler(CustomException ex) {
        log.error(ex.getMessage());
        return R.error(ex.getMessage());
    }
```

#### 12.12 控制层：CategoryController

```java
    @DeleteMapping
    public R<String> delete(Long ids){
        // 删除菜品
        categoryService.remove(ids);
        return R.success("分类信息删除成功！");
    }
```

