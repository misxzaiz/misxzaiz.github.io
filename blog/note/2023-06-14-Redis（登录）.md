# Redis（登录）

## 一、用户信息

### （1）用户表

| 属性        | 类型         | 说明                             |
| ----------- | ------------ | -------------------------------- |
| id          | bigint(20)   | UNSIGNED NOT NULL AUTO_INCREMENT |
| phone       | varchar(11)  |                                  |
| email       | varchar(20)  |                                  |
| nick_name   | varchar(32)  |                                  |
| icon        | varchar(255) |                                  |
| create_time | timestamp    |                                  |
| update_time | timestamp    |                                  |

```sql
DROP TABLE IF EXISTS tb_user;
CREATE TABLE tb_user  (
    id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
    phone varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '手机号码',
    email varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci COMMENT '邮箱',
    password varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '密码，加密存储',
    nick_name varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '昵称，默认是用户id',
    icon varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '人物头像',
    create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id) USING BTREE,
    UNIQUE (phone),
    UNIQUE (email)
) ENGINE = InnoDB AUTO_INCREMENT = 1010 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;
```

```java
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.util.Date;

@Data
@TableName("tb_user")
public class User {
    private Long id;
    private String phone;
    private String email;
    private String password;
    private String nickName;
    private String icon;
    private Date createTime;
    private Date updateTime;
}
```

## 二、任务

**发送验证码**

1. 用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号；
2. 如果手机号合法，后台会生成对应的验证码，同时将验证码进行保存（session/**redis**），然后再通过短信/邮箱的方式将验证码发送给用户。

**短信验证码登录/注册**

1. 用户将验证码和手机号/邮箱进行输入，后台从 session/**redis**中拿到当前验证码，然后和用户输入的验证码进行校验；
2. 如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户；
3. 如果用户不存在，则为用户创建账号信息，保存到数据库；
4. 无论是否存在，都会将用户信息保存到session/**redis**中，方便后续获得当前登录信息

**校验登录状态**

1. 用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session/**redis**中拿到用户信息，如果没有session/**redis**信息，则进行拦截，如果有session/**redis**信息，则将用户信息保存到threadLocal中，并且放行

## 三、发送验证码

**发送验证码**

1. 用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号；
2. 如果手机号合法，后台会生成对应的验证码，同时将验证码进行保存（session/**redis**），然后再通过短信/邮箱的方式将验证码发送给用户。

**登录接口**：

```http
get：http://127.0.0.1/user/code/phone/{phone}
```

```java
@Slf4j
@RestController
@RequestMapping("user")
public class UserController {
    @Autowired
    private UserService userService;

     /**
     * 通过手机验证码登录
     * @param phone
     * @return
     */
    @GetMapping("/code/phone/{phone}")
    public Result getCodeByPhone(@PathVariable String phone){
        return userService.getCodeByPhone(phone);
    }
}
```

```java
public class RedisUtils {
    /**
     * 登录使用：手机验证码
     */
    public static final String LOGIN_PHONE_CODE = "misxzaiz:login:phone:code:";
}
```

```java
@Slf4j
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    @Autowired
    private StringRedisTemplate stringRedisTemplate;
	/**
     * 通过手机号获取验证码
     * @param phone
     * @return
     */
    @Override
    public Result getCodeByPhone(String phone) {
        // TODO 校验手机号
        if(phone.length()!=11){
            return Result.fail("手机号格式错误！");
        }
        // 生成随机验证码
        String code = RandomUtil.randomNumbers(6);
        // 保存验证码到 redis 中，超时剔除
        stringRedisTemplate.opsForValue().set(LOGIN_PHONE_CODE+phone,code,1,TimeUnit.MINUTES);
        // TODO 发送验证码
        log.info("【验证码登录】{} 的验证码为：{}",phone,code);
        return Result.ok("验证码获取成功！");
    }
}
```

- RandomUtil：cn.hutool 的工具类

## 四、登录

登录接口：

```http
post：http://127.0.0.1/user/login/phone/code
data：form: {"phone":"",code:""}
```

### （1）返回用户信息 UserDto

```java
@Data
public class UserDto {
    private Long id;
    private String nickName;
    private String phone;
    private String email;
    private String icon;
}
```

### （2）登录信息

```java
@Data
public class LoginForm {
    private String phone;
    private String email;
    private String code;
    private String password;
}
```

### （3）Redis 的 key 前缀

```java
public class RedisUtils {
    /**
     * 保存用户登录信息
     */
    public static final String LOGIN_USER_KEY = "misxzaiz:user:";
}
```

### （4）登录

```java
@Slf4j
@RestController
@RequestMapping("user")
public class UserController {
    @Autowired
    private UserService userService;
    
	/**
     * 通过手机号和验证码登录
     * @param form
     * @return
     */
    @PostMapping("/login/phone/code")
    public Result loginWithPhoneByCode(@RequestBody LoginForm form){
        log.info("【登录】phone：{}\tcode：{}",form.getPhone(),form.getCode());
        return userService.loginWithPhoneByCode(form);
    }
}
```

@Slf4j是Lombok提供的注解，它可以在编译时自动为类生成一个org.slf4j.Logger类型的log属性，用于输出日志。

@Service注解表示该类是一个Spring Bean，用于作为服务层组件进行业务处理。该类实现了UserService接口，并继承了ServiceImpl抽象类，实现了对用户信息的登录、注册等业务操作。

loginWithPhoneByCode()方法用于处理用户使用手机号和验证码登录的请求。首先从参数中获取手机号和验证码，然后校验手机号格式。接着从redis中获取缓存的验证码进行验证，如果不一致，则返回验证码错误。如果验证通过，则根据手机号查询用户信息，如查询不到则创建一个新用户（createUserWithPhone()方法）。完成用户信息的保存之后，将用户信息转为HashMap并存储到redis中，使用UUID生成token作为登录令牌，将token作为key，将用户信息添加到redis的hash中，并设置有效期为7天。最后将令牌返回给客户端。

createUserWithPhone()方法用于根据给定的手机号创建一个新用户，设置手机号和随机生成的昵称，并将用户信息写入数据库。

```java
@Slf4j
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    /**
     * 通过手机号和验证码登录
     * @param form
     * @return
     */
    @Override
    public Result loginWithPhoneByCode(LoginForm form) {
        String phone = form.getPhone();
        String code = form.getCode();
        // TODO 校验手机号
        if(phone.length()!=11){
            return Result.fail("手机号格式错误！");
        }
        // 从 redis 中获取验证码并校验
        String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_PHONE_CODE + phone);
        if (cacheCode == null || !cacheCode.equals(code)) {
            // 验证码错误
            return Result.fail("验证码错误！");
        }
        // 根据手机号查询用户
        User user = query().eq("phone", phone).one();
        // 判断用户是否存在
        if (user == null) {
            // 不存在，注册，创建一个用户
            user = createUserWithPhone(phone);
        }
        // 保存用户信息到 redis
        // 随机生成 token 作为登录令牌
        String token = UUID.randomUUID().toString();
        // 将 user 对象转换为 HashMap 存在
        UserDto userDto = BeanUtil.copyProperties(user, UserDto.class);
        Map<String, Object> userMap = BeanUtil.beanToMap(userDto, new HashMap<>(),
                CopyOptions.create()
                        .setIgnoreNullValue(true)
                        .setFieldValueEditor((fieldName, fieldValue) ->
                                fieldValue == null ? "" : fieldValue.toString()));
        // 存储
        String tokenKey = LOGIN_USER_KEY+token;
        stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);
        // 设置 token 有效期
        stringRedisTemplate.expire(tokenKey,7,TimeUnit.DAYS);
        // 返回 token
        return Result.ok(token,"登录成功！");
    }

    /**
     * 根据手机号创建用户
     * @param phone
     * @return
     */
    private User createUserWithPhone(String phone) {
        User user = new User();
        user.setPhone(phone);
        user.setNickName("用户"+RandomUtil.randomNumbers(6));
        save(user);
        return user;
    }
}
```

### （5）测试请求（用户检验登录拦截）

```java
@Slf4j
@RestController
@RequestMapping("user")
public class UserController {
    @GetMapping("/test/login/intercept")
    public Result testLoginIntercept(){
        return Result.ok("登录成功！");
    }
}
```

### （6）User 的 ThreadLocal

这段代码定义了一个UserHolder类，用于在线程内存储用户信息，保证用户信息在线程间隔离，以避免线程安全问题。

该类中使用ThreadLocal来存储用户信息，它是一个线程本地变量，每个线程都拥有自己的副本，互不干扰。其中包含三个方法：

- saveUser(UserDto user)：用于保存user对象到ThreadLocal中。
- getUser()：获取当前线程中的user对象，如果没有存储，则返回null。
- removeUser()：用于清除当前线程中存储的user对象。

在多线程环境下，如果多个线程都需要访问同一个对象，往往会出现线程安全问题。使用ThreadLocal可以解决这个问题，因为它能够确保每个线程独立地访问自己的对象，在一个线程中修改数据不会影响到其他线程中的数据。这样就保证了数据的安全性和线程间的隔离性。

```java
public class UserHolder {
    private static final ThreadLocal<UserDto> tl = new ThreadLocal<>();

    public static void saveUser(UserDto user){
        tl.set(user);
    }

    public static UserDto getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

### （7）拦截器

​	这是一个拦截器类，用于进行用户身份验证和处理跨域问题。该类实现了HandlerInterceptor接口，并且包含了preHandle()和afterCompletion()两个方法。

​	在preHandle()方法中，首先判断当前请求是否为OPTIONS请求，如果是，则设置响应头信息以允许跨域请求，并返回false表示请求被拦截；如果不是，则获取请求头中的token，如果token为空，则设置状态码为401，并返回false表示请求被拦截；如果token不为空，则根据token从redis中获取对应的用户信息，并将用户信息保存到ThreadLocal中。最后，刷新token有效期并返回true表示放行请求。

​	在afterCompletion()方法中，移除保存在ThreadLocal中的用户信息。

​	可以将该拦截器配置到Spring MVC的**拦截器链**中，在每次请求处理之前先进行身份验证和跨域处理。如果验证不通过或者跨域被拒绝，请求就会被拦截，不会进入具体的Controller方法中。

```java
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.util.StrUtil;
import org.example.dto.UserDto;
import org.example.utils.UserHolder;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.Map;
import java.util.concurrent.TimeUnit;

import static org.example.utils.RedisUtils.LOGIN_USER_KEY;

public class LoginInterceptor implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public LoginInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 处理跨域问题
        if (request.getMethod().equals("OPTIONS")) {
            response.setHeader("Access-Control-Allow-Origin", "*");
            response.setHeader("Access-Control-Allow-Methods", "GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH");
            response.setHeader("Access-Control-Max-Age", "86400");
            response.setHeader("Access-Control-Allow-Headers", "*");
            return false;
        }

        // 获取请求头中的token
        String token = request.getHeader("Authorization");
        if (StrUtil.isBlank(token)) {
            // 没有，需要拦截，设置状态码
            response.setStatus(401);
            // 拦截
            return false;
        }
        // 基于TOKEN获取redis中的用户
        String key  = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
        // 判断用户是否存在
        if (userMap.isEmpty()) {
            // 没有，需要拦截，设置状态码
            response.setStatus(401);
            // 拦截
            return false;
        }
        // 5.将查询到的hash数据转为UserDTO
        UserDto userDto = BeanUtil.fillBeanWithMap(userMap, new UserDto(), false);
        // 6.存在，保存用户信息到 ThreadLocal
        UserHolder.saveUser(userDto);
        // 7.刷新token有效期
        stringRedisTemplate.expire(key, 7, TimeUnit.DAYS);
        // 8.放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 移除用户
        UserHolder.removeUser();
    }
}
```

### （8）使能拦截器

​	这是一个Spring MVC的配置类，实现了WebMvcConfigurer接口，用于配置拦截器。

​	在addInterceptors()方法中，首先创建一个LoginInterceptor拦截器实例，并将其注册到拦截器链中。然后对拦截器进行了一些配置，其中：

- excludePathPatterns()方法表示排除某些URL不进行拦截，这里排除了以"/user/code/"和"/user/login/"开头的URL。
- addPathPatterns()方法表示拦截所有请求，即所有请求都会经过该拦截器进行处理。
- order()方法表示拦截器的执行顺序，该拦截器的顺序为0，数字越小表示优先级越高。

​	因此，该配置类将LoginInterceptor拦截器注册到Spring MVC的拦截器链中，并将其应用到项目中的所有请求中。在拦截器处理中，除了排除的URL之外的所有请求都需要进行身份验证和跨域处理。

```java
import org.example.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.annotation.Resource;

@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截器
        registry.addInterceptor(new LoginInterceptor(stringRedisTemplate))
                .excludePathPatterns(
                        "/user/code/**",
                        "/user/login/**"
                )
                .addPathPatterns("/**").order(0);

    }
}
```



