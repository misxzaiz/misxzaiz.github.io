# 文件（分片）

## 一、文件信息

| 属性名         | 数据类型     | 说明                    |
| -------------- | ------------ | ----------------------- |
| id             | bigint       | 主键                    |
| path           | varchar(100) | 相对路径                |
| name           | varchar(100) | 文件名                  |
| primitive_name | varchar(100) | 文件原名                |
| suffix         | varchar(10)  | 后缀                    |
| size           | int          | 大小（单位：字节B）     |
| use            | char         | 用途                    |
| create_time    | timestamp    | 创建时间                |
| update_time    | timestamp    | 更新时间                |
| shard_index    | int          | 已上传分片              |
| shard_size     | int          | 分片大小（单位：字节B） |
| shard_total    | int          | 分片总数                |
| key            | varchar(32)  | 文件标识                |

### 数据表

```sql
CREATE TABLE `tb_file` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `path` varchar(100) NOT NULL COMMENT '相对路径',
  `name` varchar(100) DEFAULT NULL COMMENT '文件名',
  `primitive_name` varchar(100) DEFAULT NULL COMMENT '文件原名',
  `suffix` varchar(10) DEFAULT NULL COMMENT '后缀',
  `size` int(11) DEFAULT NULL COMMENT '大小|字节B',
  `file_use` char(1) DEFAULT NULL COMMENT '用途',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `shard_index` int(11) DEFAULT NULL COMMENT '已上传分片',
  `shard_size` int(11) DEFAULT NULL COMMENT '分片大小|B',
  `shard_total` int(11) DEFAULT NULL COMMENT '分片总数',
  `md5_key` varchar(32) DEFAULT NULL COMMENT '文件标识',
  PRIMARY KEY (`id`),
  UNIQUE KEY `path_unique` (`path`),
  UNIQUE KEY `key_unique` (`md5_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文件';
```

### File 实体类

```java
import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.util.Date;

@Data
@TableName("tb_file")
public class File {
    private Long id;
    private String path;
    private String name;
    private String primitiveName;
    private String suffix;
    private Integer size;
    private Character fileUse;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updateTime;
    private Integer shardIndex;
    private Integer shardSize;
    private Integer shardTotal;
    private String md5Key;
}
```

### FileDto 封装类

```java
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.util.Date;

@Data
public class FileDto {

    private Long id;
    private String path;
    private String name;
    private String primitiveName;
    private String suffix;
    private Integer size;
    private String fileUse;
    private Integer shardIndex;
    //   base64 字符串
    private String  shard;
    private Integer shardSize;
    private Integer shardTotal;
    private String md5Key;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updateTime;

}
```



## 二、任务

1. 检查文件标识符，判断文件是否存在，实现妙传；
2. 文件分片上传

## 三、检查文件标识符

```java
@Slf4j
@RestController
@RequestMapping("/file")
public class FileController {


    @Autowired
    private FileService fileService;

    /**
     * 根据前端生成的MD5标识查询文件
     */
    @GetMapping("/check/{md5Key}")
    public Result check(@PathVariable String md5Key) throws Exception {
        log.info("【文件上传】检查上传分片开始：{}", md5Key);
        FileDto fileDto = fileService.findByKey(md5Key);
        if (fileDto == null) {
            return Result.fail("不存在该文件！");
        }
        return Result.ok(fileDto,"该文件已存在！");
    }
}
```

```java
@Slf4j
@Service
public class FileServiceImpl extends ServiceImpl<FileMapper, File> implements FileService {
	private File selectByKey(String md5Key){
        return query().eq("md5_key", md5Key).one();
    }

    @Override
    public FileDto findByKey(String md5Key) {
        File file = selectByKey(md5Key);
        if (file == null) {
            return null;
        }
        return BeanUtil.copyProperties(file,FileDto.class);
    }
}
```



## 四、分片上传

```java
    /**
     * 分片上传
     */
    @PostMapping("/upload")
    public Result upload(@RequestBody FileDto fileDto) throws Exception {
        return fileService.uploadFile(fileDto);
    }
```

```java
    @Value("${file.path}")
    private String FILE_PATH;

    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Override
    public void saveFile(FileDto fileDto) {
        File file = BeanUtil.copyProperties(fileDto,File.class);
        // 根据key值去数据库查询File
        File fileDb = selectByKey(fileDto.getMd5Key());
        // 判断是新增 还是修改
        if (fileDb == null) {
            save(file);
        } else {
            // 如果是更新的话 先更改文件的ShardIndex属性 在update
            fileDb.setShardIndex(fileDto.getShardIndex());
            updateById(file);
        }
    }

    private File selectByKey(String md5Key){
        return query().eq("md5_key", md5Key).one();
    }

    @Override
    public FileDto findByKey(String md5Key) {
        File file = selectByKey(md5Key);
        if (file == null) {
            return null;
        }
        return BeanUtil.copyProperties(file,FileDto.class);
    }

    @Override
    public Result uploadFile(FileDto fileDto) throws Exception {
        // 检查数据库中是否存在该文件的信息
        FileDto fileDtoDatabase = findByKey(fileDto.getMd5Key());
        String fileName = null;
        // 数据库中不存在文件信息
        if(fileDtoDatabase == null){
            // 生成随机存储文件名
            fileName = UUID.randomUUID().toString()+"."+fileDto.getSuffix();
            fileDto.setName(fileName);
            fileDto.setPath(FILE_DOMAIN + fileName);
        }
        // 检查分片
        Integer index = fileDto.getShardIndex();
        if(fileDto.getShardTotal()!=index){
            fileDto.setShardIndex(++index);
            saveFile(fileDto);
            merge(fileDto);
        }
        return Result.ok(fileDto,"文件上传！");
    }


    //合并分片
    private void merge(FileDto fileDto) throws Exception {
        log.info("合并分片开始");
        // 文件存储的位置
        String fileUploadPath = FILE_PATH;
        // 文件名
        String fileName = fileDto.getName();
        // 文件二进制，包含前缀 data:application/octet-stream;base64,
        String shard = fileDto.getShard();

        // 将二进制数据解码为字节数组
        byte[] content = Base64.getDecoder().decode(shard.split(",")[1]);
        // byte[] content = Base64.getDecoder().decode(shard);

        // 将分片写入本地磁盘
        // 创建文件夹
        java.io.File file = new java.io.File(fileUploadPath);
        if (!file.exists() && !file.isDirectory()) {
            boolean success = file.mkdirs(); // 创建目录
            if (!success) {
                throw new RuntimeException("Failed to create directory: " + file.getAbsolutePath());
            }
        }
        // 创建文件
        java.io.File targetFile = new java.io.File(file, fileName);

        // FileOutputStream

        FileOutputStream fos = new FileOutputStream(targetFile, true);
        fos.write(content);
        fos.close();
    }
```



## 五、前端页面







































```java
@RequestMapping("/admin/file")
@RestController
public class UploadController {

    private static final Logger LOG = LoggerFactory.getLogger(UploadController.class);
    public  static final String BUSINESS_NAME ="文件上传";
    @Resource
    private TestService testService;

    @Value("${file.path}")
    private String FILE_PATH;

    @Value("${file.domain}")
    private String FILE_DOMAIN;

    @Resource
    private FileService fileService;

    @RequestMapping("/upload")
    public ResponseDto upload(@RequestBody FileDto fileDto) throws Exception {

        FileDto fileDtoDatabase = fileService.findByKey(fileDto.getKey());

        String fileName = null;

        if(fileDtoDatabase == null){
            fileName = UUID.randomUUID().toString()+"."+fileDto.getSuffix();
            fileDto.setName(fileName);
            fileDto.setPath(FILE_DOMAIN + fileName);

        } else {

            fileName = fileDtoDatabase.getName();

        }
        fileDto.setName(fileName);

        Integer index = fileDto.getShardIndex();
        if(fileDto.getShardTotal()!=index){
            fileDto.setShardIndex(++index);
        }

        fileService.save(fileDto);

        merge(fileDto);

        ResponseDto responseDto = new ResponseDto();


        responseDto.setContent(fileDto);

        return responseDto;

    }

    //合并分片
    public void merge(FileDto fileDto) throws Exception {
        LOG.info("合并分片开始");
        String fileUploadPath = FILE_PATH;              // 文件存储的位置
        String fileName = fileDto.getName();            // 文件名
        String shard = fileDto.getShard();              // 文件二进制，包含前缀 data:application/octet-stream;base64,

        // 将二进制数据解码为字节数组
        byte[] content = Base64.getDecoder().decode(shard.split(",")[1]);
        // byte[] content = Base64.getDecoder().decode(shard);

        // 将分片写入本地磁盘
        // 创建文件夹
        File file = new File(fileUploadPath);
        if (!file.exists() && !file.isDirectory()) {
            boolean success = file.mkdirs(); // 创建目录
            if (!success) {
                throw new RuntimeException("Failed to create directory: " + file.getAbsolutePath());
            }
        }
        // 创建文件
        File targetFile = new File(file, fileName);

        // FileOutputStream
        System.out.println("content:"+content);
        FileOutputStream fos = new FileOutputStream(targetFile, true);
        fos.write(content);
        fos.close();

    }

    @GetMapping("/check/{key}")
    public ResponseDto check(@PathVariable String key) throws Exception {
        ResponseDto responseDto = new ResponseDto();

        LOG.info("检查上传分片开始：{}", key);
        FileDto fileDto = fileService.findByKey(key);
        responseDto.setContent(fileDto);

        return responseDto;
    }

}//end class
```



