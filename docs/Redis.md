1. 缓存穿透 & 双写一致

> 缓存空对象解决`缓存穿透`问题，`双写一致策略`保证数据的一致性

2. 缓存`穿透`、缓存`击穿`和缓存`雪崩`
   - 缓存穿透：布隆过滤器、缓存空对象
   - 缓存击穿（热点数据）：互斥锁（强一致）、逻辑过期（高可用）
   - 缓存雪崩（大量数据同时失效）：随机过期时间

3. 双写一致

   > 延时双删

4. 分布式唯一ID

   - `Redis`的`String`自增：
     - 0（1 bit）
     - 时间戳（31 bit）
     - 序列号（32 bit）

   - 雪花算法（64 bit）：
     - 0（1 bit）
     - 时间戳（41 bit）：`时间回拨问题`
     - 机器码（10 bit）
     - 序列号（12 bit）

   注意：`js`的`Number`最大只支持`53`位，因此需要转换为`String`类型

   - `时间回拨问题`：
     - 时钟同步：网络时间协议（NTP）确保各个节点的系统时钟保持同步
     - 时间漂移补偿
     - 拒绝生成ID
     - 使用更长的时间戳
     - 检测和处理时间回拨事件
     - 启动前检测
     - 异常处理
     - 备用ID

   注意：`机器码`不能解决同一节点的时钟回拨问题

5. 分布式锁

6. 消息队列

7. 数据结构

8. 主从集群

> 读写分离

9. 分片集群

> 动态扩容

10. 哨兵

> 故障恢复问题

11. 持久化

> 数据丢失问题

- RDB（Redis Database Backup file）：数据备份文件
  - Redis命令：
    - save：由Redis主进程来执行RDB，会阻塞所以命令
    - bgsave：fork一个`子进程`（不是线程）执行RDB，子进程通过`页表`共享主进程的内存数据
  - 默认持久化：停机（如 ctrl + c 断开连接）
  - 触发机制：
    - redis.conf 文件的 save 配置：时间 & 修改次数
  - bgsave 问题：主进程修改数据
    - `copy-on-write` 技术：主进程拷贝一份数据，并修改主进程页表的映射关系，子进程还是保持原来的旧数据
      - 极端情况：所有数据都被修改一遍，导致内存占用翻倍

- AOP（Append-Only file ）：追加文件
  - 记录写命令
  - 默认关闭
  - 开启配置：redis.conf：appendonly yes
  - 频率
    - appendfsync always：每次写命令
    - appendfsync everysec（默认）：先将命令写入缓冲区，每秒将缓冲区数据写到 AOF 文件
    - appendfsync no：由操作系统决定写入时机