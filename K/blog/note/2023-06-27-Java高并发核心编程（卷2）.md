[TOC]

# Java 高并发核心编程（卷2）

Java 多线程、线程池、内置锁、JMM、CAS、JUC、高并发设计模式、Java 异步回调、CompletableFuture

| 章节                             | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 第一章 多线程                    | 第1章介绍线程的核心原理、线程的基本操作、线程池的核心原理、JUC的线程池架构、4种快捷创建线程池的方法。除此之外，还从生产实际的角度出发，介绍在生产场景中如何合理预估3类线程池（IO密集型、CPU密集性、混合型）的线程数。 |
| 第二章 Java内置锁                | 第2章基于生产者－消费者模式的实战案例介绍线程安全问题和Java内置锁的核心原理。首先揭秘Java对象的存储布局、对象头的具体结构，并介绍如何用JOL工具查看对象的结构。然后介绍synchronized内置锁的核心原理，以及内置锁从偏向锁到轻量级锁再到重量级锁的升级过程。 |
| 第三章 CAS和JUC原子类            | 第3章介绍CAS原理与JUC原子类，并解密在争用激烈的高并发场景下，如何提升高CAS操作的性能。最后揭秘CAS操作的弊端和两类规避措施。 |
| 第四章 可见性和有序性            | 第4章介绍Java并发编程的三大问题——原子性问题、可见性问题和有序性问题，阐述JMM的核心原理，揭秘Java内存可见性和volatile关键字的底层知识。 |
| 第五章 JUC显示锁                 | 第5章介绍JUC显式锁的原理与实战。首先介绍使用显式锁的正确方法、显式锁的分类，然后揭秘CAS可能导致的“总线风暴”和CLH自旋锁，最后从实例出发介绍JUC中的可中断锁和不可中断锁、共享锁与独占锁、读写锁。 |
| 第六章 AQS抽象同步器             | 第6章介绍JUC高并发的基础设施——AQS抽象同步器的核心原理。本章从模板模式入手，抽丝剥茧，层层深入，揭秘AQS的内部结构。然后结合SimpleMockLock独占锁的释放流程、ReentrantLock的抢锁流程，图文并茂地剖析释放、抢占AQS锁的源码和原理。 |
| 第七章 JUC容器类                 | 第7章介绍JUC容器类，包括CopyOnWriteArrayList、BlockingQueue、ConcurrentHashMap等高并发容器类的原理和使用。 |
| 第八章 高并发设计模式            | 第8章介绍高并发设计模式，主要包括Java开发必须掌握的安全单例模式、Master-Worker模式、ForkJoin模式、生产者－消费者模式、Future模式。 |
| 第九章 高并发之异步回调模式      | 第9章着重介绍高并发编程中经常用到的高并发设计模式——异步回调模式。 |
| 第十章 CompletableFuture异步回调 | 第10章介绍Java 8所提供的一个具备异步回调能力的新工具类——CompletableFuture类的原理和使用。 |

## 第一章 多线程

### 1、计算机基础

- **计算机处理模式**：单用户单任务的串行处理模式 ==> 多用户多任务的高并发处理模式

- **程序**：存放在硬盘中的可执行文件，包含指令和数据。

- **进程**：一个进程是一个程序的一次启动和执行，是操作系统将程序装入内存，给程序分配必要的系统资源，并且开始运行程序的指令。

- **计算机**：CPU是核心的硬件资源，承担了所有的计算任务；内存资源承担了运行时数据的保存任务；外存资源（硬盘等）承担了数据外部永久存储的任务。

- **操作系统**：统领计算机任务的调度、资源的分配。

- **进程组成**：
  - 程序段（代码段）：是进程的程序指令在内存中的位置，包含需要执行的指令集合
  - 数据段：是进程的操作数据在内存中的位置，包含需要操作的数据集合
  - 进程控制块（Program Control Block，PCB）：包含进程的描述信息和控制信息，是进程存在的唯一标志
- **进程控制块（PCB）**：
  - 进程的描述信息：进程ID、进程名称、进程状态、进程优先级
  - 进程的调度信息：程序的起始地址、通信信息（进程间通信时的消息队列）
  - 进程的资源信息：内存信息、IO设备信息、文件句柄
  - 进程上下文：主要包括执行时各种CPU寄存器的值、当前程序计数器（PC）的值以及各种栈的值等，即进程的环境
- **Java虚拟机（JVM）**：每当使用 Java 命令启动一个 Java 应用程序时，就会启动一个 JVM 进程。在这个 JVN 进程内部，所有 Java 程序代码都是以线程来运行的。JVM 找到程序的入口点 main() 方法，然后运行 main() 方法，这样就产生一个线程，这个线程被称为主线程。当 main() 方法结束后，主线程运行完成，JVM 进程也即退出。

### 2、线程

- **线程**：进程程序段的一次顺序执行流程，一个进程可以有一个或多个线程，各个线程之间共享进程的内存、系统资源。
- **CPU调度的最小单位**：线程
- **操作系统资源分配的最小单位**：进程
- 每当使用 Java 命令执行一个 class 类时，实际上就是启动一个 JVM 进程。理论上，在该线程的内部至少会启动两个线程，一个时 main 线程，另一个是 GC（垃圾回收）线程。
- **线程组成**：
  - 线程描述信息
  - 程序计数器（Program Counter，PC）
  - 栈内存
- **线程描述信息**：
  - 线程ID（Thread ID，线程标识符）
  - 线程名称
  - 线程优先级：优先级越高，获得CPU的执行几乎越大，但不是百分百会比低优先级线程先获得。
  - 线程状态：新建、就绪、运行、阻塞、结束
  - 其他：如是否为守护线程等
- **线程的状态**（enum）：
  - NEW：新建
  - RUNNABLE：就绪、运行
  - BLOCKED：阻塞
  - WAITING：等待
  - TIMED_WAITING：计时等待
  - TERMINATED：结束

- **栈帧（方法帧）**：
  - 在 Java 中，执行程序流程的重要单位是“方法”，而栈内存的分配单位是“栈帧”。
  - 方法的每一次执行都需要为其分配一个栈帧，栈帧主要保存该方法的局部变量、方法的返回地址以及其他方法相关信息。
  - 当线程的执行流程进入方法时，JVM就会为方法分配一个对应的栈帧压入栈内存；
  - 当线程的执行流程跳出方法时，JVM就从栈内存弹出该方法的栈帧，此时方法帧的局部变量的内存空间就会被回收。
- **进程和线程的区别**：
  - 线程是“进程代码段”的一次顺序执行流程。一个进程由一个或多个线程组成，一个进程至少有一个线程。
  - 线程是CPU调度的最小单位，进程是操作系统分配资源的最小单位。线程的划分尺度小于进程，使得多线程程序的并发性高。
  - 线程是出于高并发的调度诉求从进程内部演进而来的。线程的出现既充分发挥了CPU的计算性能，又弥补了进程调度过于笨重的问题。
  - 进程之间是相互独立的，但进程内部的各个线程之间并不完全独立。各个线程之间共享进程的方法区内存、堆内存、系统资源（文件句柄、系统信号等）。
  - 切换速度不同：线程上下文切换比进程上下文切换要快得多。所以，有的时候，线程也称为轻量级进程。

#### 1. 线程基本信息

```java
        Thread t = Thread.currentThread();
        System.out.println(
                "\n线程ID：" + t.getId() +
                "\n线程名称：" + t.getName() +
                "\n线程名称：" + t.getName() +
                "\n线程优先级：" + t.getPriority() +
                "\n线程状态：" + t.getState() +
                "\n线程所属线程组：" + t.getThreadGroup() +
                "\n线程上下文类加载器：" + t.getContextClassLoader() +
                "\n线程堆栈跟踪信息：" + Arrays.toString(t.getStackTrace()) +
                "\n线程未捕获异常处理器：" + t.getUncaughtExceptionHandler() +
                "\n线程是否存活：" + t.isAlive() +
                "\n线程是否为守护线程：" + t.isDaemon() +
                "\n线程是否被中断：" + t.isInterrupted() +
                "\n线程的字符串表示：" + t.toString() +
                "\n线程的字符串表示：" + t
        );
```

```java
线程ID：1
线程名称：main
线程优先级：5
线程状态：RUNNABLE
线程所属线程组：java.lang.ThreadGroup[name=main,maxpri=10]
线程上下文类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2
线程堆栈跟踪信息：[java.lang.Thread.getStackTrace(Thread.java:1564), org.example.ThreadTest.test(ThreadTest.java:19), sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method), sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62), sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43), java.lang.reflect.Method.invoke(Method.java:498),***************,com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:55)]
线程未捕获异常处理器：java.lang.ThreadGroup[name=main,maxpri=10]
线程是否存活：true
线程是否为守护线程：false
线程是否被中断：false
线程的字符串表示：Thread[main,5,main]
```

注：***************表示省略，这个数组内还有很多信息

### 3、创建线程的四种方法

Java进程中每一个线程都对应着一个Thread实例。线程的描述信息在Thread的实例属性中得到保存，供JVM进行线程管理和调度时使用。

虽然一个进程有很多个线程，但是在一个CPU内核上，同一时刻只能有一个线程是正在执行的，该线程也被叫作当前线程。

Thread类是Java多线程编程的基础。Java中创建线程虽然有三种方式，但是三种方式都会涉及Thread类。

#### 1. Thread 类

`java.lang包`

| 方法/属性                                   | 说明                                           |
| ------------------------------------------- | ---------------------------------------------- |
| private long **tid**                        | **线程ID**                                     |
| public long getId()                         | 获取线程ID                                     |
| private String **name**                     | **线程名称**                                   |
| public final String getName()               | 获取线程名称                                   |
| public final void setName(String name)      | 设置线程名称                                   |
| Thread(String threadName)                   | 通过构造方法给线程设置名称                     |
| private int **priority**                    | **线程优先级**（10最大、1最小，默认为5）       |
| public final int getPriority()              | 获取线程优先级                                 |
| public final void setPriority(int priority) | 设置线程优先级                                 |
| private boolean **daemon**=false            | **守护线程**（默认不是，false）                |
| public final void setDaemon(boolean on)     | 设置守护线程                                   |
| private int **threadStatus**                | **线程的状态**（新建、就绪、运行、阻塞、结束） |
| public Thread.State getState()              | 获取线程状态                                   |
| public void start()                         | **启动一个线程**                               |
| public void run()                           | **线程代码逻辑的入口**                         |
| public static Thread currentThread()        | **取得当前线程**                               |

#### 2. 创建线程的方法（需要再看）

| 方法               | 说明       |
| ------------------ | ---------- |
| 继承 Thread 类     |            |
| 实现 Runnable 接口 |            |
| 实现 Callable 接口 | 带有返回值 |

#### 3. 优雅创建 Runnable 线程目标类

（1）通过匿名类创建 Runnable 线程目标类

（2）使用 Lambda 表达式创建 Runnable 线程目标类

#### 4. 通过匿名类创建 Runnable 线程目标类

```java
public class CreateWithRunnable {
    public static final int MAX_TURN = 5;
    static int threadNo = 1;

    public static void main(String[] args) {
        Thread thread = null;
        for (int i = 0; i < 2; i++) {
            thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < MAX_TURN; j++) {
                        System.out.println(Thread.currentThread().getName());
                    }
                }
            }, "RunnableThread" + threadNo ++);
            thread.start();
        }
    }
}
```

#### 5. 使用 Lambda 表达式创建 Runnable 线程目标类

函数式接口：有且仅有一个抽象方法的接口，@FunctionalInterface注解可标识该抽象方法，不使用注解也没事，但如果一个接口中包含两个或两个以上的抽象方法，就不能使用该注解

```java
public class CreateWithRunnable {
    public static final int MAX_TURN = 5;
    static int threadNo = 1;

    public static void main(String[] args) {
        Thread thread = null;
        for (int i = 0; i < 2; i++) {
            thread = new Thread(() -> {
                for (int j = 0; j < MAX_TURN; j++) {
                    System.out.println(Thread.currentThread().getName());
                }
            }, "RunnableThread" + threadNo ++);
            thread.start();
        }
    }
}
```

#### 6. 使用 Runnable 创建线程的优缺点

缺点：

（1）所创建的类并不是线程类，而是线程的target执行目标类，需要将其实例作为参数传入线程类的构造器，才能创建真正的线程。

（2）如果访问当前线程的属性（甚至控制当前线程），不能直接访问Thread的实例方法，必须通过Thread.currentThread()获取当前线程实例，才能访问和控制当前线程。

优点：

（1）可以避免由于Java单继承带来的局限性。

（2）逻辑和数据更好分离。

#### 7. Runnable 逻辑和数据分离

在Java中，Runnable接口是用来定义线程任务的，并非直接创建线程。因此，实现了Runnable接口的类内部的属性是可以共享的。这种设计方式使得多个线程可以访问和操作同一个对象的属性，从而实现数据共享的功能。

当我们创建一个线程时，通常会将Runnable对象传递给Thread类的构造方法来指定线程的任务。然后，通过调用Thread对象的start()方法来启动线程，使其开始执行Runnable对象中定义的逻辑。

由于多个线程可以共享同一个Runnable对象，因此它们可以访问和修改Runnable对象内部的属性。这样就能够实现线程之间的数据交互和通信。然而，需要注意的是，在多线程环境下对共享数据进行操作时，需要采取适当的同步措施，以防止出现竞态条件等并发问题。

总之，实现了Runnable接口的类能够将线程的逻辑与数据进行分离，使得多个线程可以方便地共享同一份数据，从而更灵活地实现并发编程任务。

```java
package org.example.demo;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SalesDemo {

    // 商品数量
    private static final int MAX_AMOUNT = 5;
    static class MallGoods implements Runnable {
        // 使用原子数据类型保证数据安全
        private AtomicInteger goodsAmount = new AtomicInteger(MAX_AMOUNT);
        // 使用锁保证数据安全
        private final Lock lock = new ReentrantLock();
        @Override
        public void run() {
            for (int i = 0; i <= MAX_AMOUNT; i++) {
                lock.lock();
                try {
                    if (this.goodsAmount.get() > 0) {
                        System.out.println(Thread.currentThread().getName() +
                                "卖出一件，还剩：" +
                                goodsAmount.decrementAndGet());
                    }
                } finally {
                    lock.unlock();
                }
                try {
                    // 模拟业务处理时间
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println(Thread.currentThread().getName()+"运行结束");
        }
    }

    public static void main(String[] args) {
        MallGoods mallGoods = new MallGoods();
        for (int i = 0; i < 2; i++) {
            Thread thread = null;
            thread = new Thread(mallGoods, "商品销售员-" + i);
            thread.start();
        }
    }
}
```

#### 8. Callable 和 FutureTask

##### Callable 接口

```java
package java.util.concurrent;

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

##### RunnableFuture 接口

一是可以作为Thread线程实例的target实例，二是可以获取异步执行的结果。

```java
package java.util.concurrent;

public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}
```

##### Future 接口

Future接口至少提供了三大功能：

（1）能够取消异步执行中的任务。

（2）判断异步任务是否执行完成。

（3）获取异步任务完成后的执行结果。

```java
package java.util.concurrent;

public interface Future<V> {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

##### FutureTask 类

FutureTask类是Future接口的实现类，提供了对异步任务的操作的具体实现。但是，FutureTask类不仅实现了Future接口，还实现了Runnable接口，或者更加准确地说，FutureTask类实现了RunnableFuture接口。

```java
// 保存并发执行的 Callable<V> 类型的任务
private Callable<V> callable
// 保存 callable 成员 call() 方法的异步执行结果
private Object outcome;
```

#### 9. 使用Callable和FutureTask创建线程

（1）创建一个Callable接口的实现类，并实现其call()方法，编写好异步执行的具体逻辑，可以有返回值。

（2）使用Callable实现类的实例构造一个FutureTask实例。

（3）使用FutureTask实例作为Thread构造器的target入参，构造新的Thread线程实例。

（4）调用Thread实例的start()方法启动新线程，启动新线程的run()方法并发执行。其内部的执行过程为：启动Thread实例的run()方法并发执行后，会执行FutureTask实例的run()方法，最终会并发执行Callable实现类的call()方法。

（5）调用FutureTask对象的get()方法阻塞性地获得并发线程的执行结果。

```java
package org.example.demo;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableDemo {
    private static final int MAX_TURN = 5;
    private static final int COMPUTE_TIMES = 100000000; // 不用数了，这里是8个0

    // 创建一个 Callable 接口的实现类
    static class ReturnableTask implements Callable<Long> {
        // 编写好异步执行的具体逻辑，可以有返回值
        @Override
        public Long call() throws Exception {
            long startTime = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() + "线程开始执行！");
            Thread.sleep(1000);

            for (int i = 0; i < COMPUTE_TIMES; i++) {
                int j = i * 10000;
            }
            long used = System.currentTimeMillis() - startTime;
            System.out.println(Thread.currentThread().getName() + "线程执行完成！");
            return used;
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ReturnableTask task = new ReturnableTask();
        FutureTask<Long> futureTask = new FutureTask<Long>(task);
        Thread thread = new Thread(futureTask, "returnableThread");

        thread.start();
        Thread.sleep(500);
        System.out.println("线程执行时间："+futureTask.get());
    }
}
```

（1）futureTask的结果outcome不为空，callable.call()执行完成。在这种情况下，futureTast.get会直接取回outcome结果，返回给main线程（结果获取线程）。

（2）futureTask的结果outcome为空，callable.call()还没有执行完。在这种情况下，main线程作为结果获取线程会被阻塞住，一直阻塞到callable.call()执行完成。当执行完后，最终结果会保存到outcome中，futureTask会唤醒main线程，去提取callable.call()执行结果。

#### 10. 通过线程池创建线程（Executors）

前面的示例中，所创建的Thread实例在执行完成之后都销毁了，这些线程实例都是不可复用的。实际上创建一个线程实例在时间成本、资源耗费上都很高（稍后会介绍），在高并发的场景中，断然不能频繁进行线程实例的创建与销毁，而是需要对已经创建好的线程实例进行复用，这就涉及线程池的技术。Java中提供了一个静态工厂来创建不同的线程池，该静态工厂为**Executors**工厂类。

（1）线程池的创建与执行目标提交

通过Executors工厂类创建一个线程池：
```java
// 创建一个包含三个线程的线程池
private static ExecutorService pool = Executors.newFixedThreadPool(3);
```

ExecutorService是Java提供的一个线程池接口，每次我们在异步执行target目标任务的时候，可以通过ExecutorService线程池实例去提交或者执行。ExecutorService实例负责对池中的线程进行管理和调度，并且可以有效控制最大并发线程数，提高系统资源的使用率，同时提供定时执行、定频执行、单线程、并发数控制等功能。

向ExecutorService线程池提交异步执行target目标任务的常用方法有：

```java
// 执行一个 Runnable 类型的 target 执行目标实例，无返回
void execute(Runnable command);
// 提交一个 Callable 类型的 target 执行目标实例，返回一个 Future 异步任务实例
<T> Future<T> submit(Callable<T> task);
// 提交一个 RUnnablee 类型的 target 执行目标实例，返回一个 Future 异步任务实例
Future<?> submit(Runnable task);
```

#### 11. 使用线程池创建线程实例

```java
package org.example.demo;

import java.util.concurrent.*;

public class ExecutorsDemo {
    private static final int MAX_TURN = 5;
    private static final int COMPUTE_TIMES = 100000000; // 不用数了，这里是8个0
    // 创建一个包含三个线程的线程池
    private static ExecutorService pool = Executors.newFixedThreadPool(3);
    static class DemoThread implements Runnable {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + "线程开始执行！");
            for (int i = 0; i < MAX_TURN; i++) {
                System.out.println(Thread.currentThread().getName() + "执行第" + i + "次！");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println(Thread.currentThread().getName() + "线程执行结束！");
        }
    }

    static class ReturnableTask implements Callable<Long> {
        @Override
        public Long call() throws Exception {
            long startTime = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() + "线程开始执行！");
            for (int i = 0; i < MAX_TURN; i++) {
                System.out.println(Thread.currentThread().getName() + "执行第" + i + "次！");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println(Thread.currentThread().getName() + "线程执行结束！");
            long used = System.currentTimeMillis() - startTime;
            return used;
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 执行线程实例，无返回
        pool.execute(new DemoThread());
        pool.execute(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < MAX_TURN; i++) {
                    System.out.println(Thread.currentThread().getName() + "执行第" + i + "次！");
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });
        Future<Long> future = pool.submit(new ReturnableTask());
        Long result = future.get();
        System.out.println("异步任务的执行结果为：" + result);
        Thread.sleep(1000);
    }

}
```

### 4、线程的核心原理

现代操作系统（如Windows、Linux、Solaris）提供了强大的线程管理能力，Java不需要再进行独立的线程管理和调度，而是将线程调度工作委托给操作系统的调度进程去完成。在某些系统（比如Solaris操作系统）上，JVM甚至将每个Java线程一对一地对应到操作系统的本地线程，彻底将线程调度委托给操作系统。

#### 1. 线程的调度与时间片

- 线程调度模型：分时调度模型、抢占式调度模型：由于目前大部分操作系统都是使用抢占式调度模型进行线程调度，Java的线程管理和调度是委托给操作系统完成的，与之相对应，Java的线程调度也是使用抢占式调度模型，因此Java的线程都有优先级。

#### 2. 线程的优先级

（1）整体而言，高优先级的线程获得的执行机会更多

（2）执行机会的获取具有随机性，优先级高的不一定获得的机会多。

#### 3. 线程的生命周期

| 生命周期      | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 创建成功但是没有调用start()方法启动的Thread线程实例都处于NEW状态。 |
| RUNNABLE      | NEW状态的Thread实例调用了start()方法后，线程的状态将变成RUNNABLE状态。尽管如此，线程的run()方法不一定会马上被并发执行，需要在线程获取了CPU时间片之后才真正启动并发执行。 |
| TERMINATED    | 处于RUNNABLE状态的线程在run()方法执行完成之后就变成终止状态TERMINATED了。当然，如果在run()方法执行过程中发生了运行时异常而没有被捕获，run()方法将被异常终止，线程也会变成TERMINATED状态。 |
| TIMED_WAITING | 线程处于一种特殊的等待状态，准确地说，线程处于限时等待状态。 |

#### 4. TIMED_WAITING

线程处于一种特殊的等待状态，准确地说，线程处于限时等待状态。能让线程处于限时等待状态的操作大致有以下几种：

（1）Thread.sleep(int n)：使得当前线程进入限时等待状态，等待时间为n毫秒。

（2）Object.wait()：带时限的抢占对象的monitor锁。

（3）Thread.join()：带时限的线程合并。

（4）LockSupport.parkNanos()：让线程等待，时间以纳秒为单位。

（5）LockSupport.parkUntil()：让线程等待，时间可以灵活设置。

### 5、线程的基本操作

Java线程的常用操作基本上都定义在Thread类中，包括一些重要的静态方法和线程实例方法。

#### 1. 线程名称的设置和获取

#### 2. 线程的 sleep 操作

#### 3. 线程的 interrupt 操作

#### 4. 线程的 join 操作

#### 5. 线程的 yield 操作

#### 6. 线程的 deamon 操作

#### 7. 线程的状态总结



















