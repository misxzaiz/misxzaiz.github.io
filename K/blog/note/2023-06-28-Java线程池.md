# Java线程池

参考资料：[《Java高并发核心编程（卷2）》](https://weread.qq.com/web/bookDetail/9b93254072456ac19b9a176)

[TOC]

## 一、基本概念

### 1、创建线程的成本：

> Java线程的创建非常昂贵，需要JVM和OS（操作系统）配合完成大量的工作：
>
> （1）内存：必须为线程堆栈分配和初始化大量内存块，其中包括至少1MB的栈内存；
>
> （2）系统：需要进行系统调用，以便在OS（操作系统）中创建和注册本地线程。

### 2、使用线程池的好处

> Java高并发应用频繁创建和销毁线程的操作是非常低效的，而且是不被编程规范所允许的。
>
> 线程池主要解决以下两个问题：
>
> （1）提高性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。
>
> （2）线程管理：每个Java线程池会保持一些基本的线程统计信息，如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步人物为进行高效调度。

## 二、JUC的线程池架构

> **JUC**就是java.util.concurrent工具包的简称，该工具包是从JDK 1.5开始加入JDK的，是用于完成**高并发**、**处理多线程**的一个工具包。
>
> 在多线程编程中，任务都是一些抽象且离散的工作单元，而线程是使任务异步执行的基本机制，为了简化这些复杂的**线程管理模式**，我们使用**线程池**来统一管理线程及任务分配。

| 类/接口                          | 说明 |
| -------------------------------- | ---- |
| Executor（接口）                 |      |
| ExecutorService（接口）          |      |
| Executors                        |      |
| AbstractExecutorService          |      |
| ThreadPoolExecutor               |      |
| ScheduledExecutorService（接口） |      |
| ScheduledThreadPoolExecutor      |      |

图 JUC中线程池的类与接口的架构

![img](assets/epub_38103745_16)

### 1、Executor（接口）

> Executor是Java异步目标任务的“执行者”接口，其目标是**执行目标任务**。
>
> “执行者”Executor提供了execute()接口来**执行已提交的Runnable执行目标实例**。
>
> Executor作为执行者的角色，其目的是**提供一种将“任务提交者”与“任务执行者”分离开来的机制**。
>
> 它只包含一个**函数式方法**：

```java
void execute(Runnable command)
```



### 2、ExecutorService（接口）

> ExecutorService继承于Executor。
>
> 它是Java异步目标任务的“执行者服务接”口，**对外提供异步任务的接收服务**。
>
> ExecutorService提供了“**接收异步任务并转交给执行者**”的方法，如submit系列方法、invoke系列方法等，具体如下：

```java
// 向线程池提交单个异步任务
<T> Future<T> submit(Callable<T> task)
// 向线程池提交批量异步任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
```



### 3、AbstractExecutorService

> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的接口**提供默认实现**。



### 4、 ThreadPoolExecutor

> ThreadPoolExecutor就是大名鼎鼎的“线程池”实现类，它继承于AbstractExecutorService抽象类。
>
> ThreadPoolExecutor是JUC线程池的核心实现类。
>
> 线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控。



### 5、ScheduledExecutorService（接口）

> ScheduledExecutorService是一个接口，它继承于ExecutorService。它是一个可以完成“**延时**”和“**周期性**”任务的调度线程池接口，其功能和Timer/TimerTask类似。



### 6、ScheduledThreadPoolExecutor

> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提供了ScheduledExecutorService线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。
>
> ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。



### 7、Executors

> Executors是一个**静态工厂类**，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。



### 8、Timer（补充）

> 每个1秒输出一次

```java
    private static void extracted() {
        Timer timer = new Timer();
        TimerTask task = new TimerTask() {
            int count = 0;

            @Override
            public void run() {
                count++;
                System.out.println("输出信息 - 第 " + count + " 次");
            }
        };

        timer.scheduleAtFixedRate(task, 0, 1000);
    }
```

## 三、Executors的四种快捷创建线程的方法

> Java通过Executors工厂类提供4种快捷创建线程池的方法：

| 方法                                     | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| newSingleThreadExecutor()                | 创建只有一个线程的线程池                                     |
| newFixedThreadPool(int nThreads)         | 创建固定大小的线程池                                         |
| newCachedThreadPool()                    | 创建一个不限制线程数量的线程池，任何提交的任务都将立即执行，但是空闲线程会得到及时回收 |
| newSingleThreadScheduledExecutor()       | 创建一个可调度的线程池，池内仅含一个线程                     |
| newScheduledThreadPool(int corePoolSize) | 创建一个可调度的线程池，池内仅含 corePoolSize 个线程         |

### 1、newSingleThreadExecutor创建“单线程化线程池”

> 该方法用于创建一个“单线程化线程池”，也就是只有一个线程的线程池，所创建的线程池用唯一的工作线程来执行任务，使用此方法创建的线程池能**保证所有任务按照指定顺序（如FIFO）执行**。
>
> 特点：
>
> （1）单线程化的线程池中的任务是**按照提交的次序顺序执行**的。
>
> （2）池中的唯一线程的**存活时间是无限的**。
>
> （3）当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其**阻塞队列是无界的**。

```java
package org.example.demo.executor;

import java.util.concurrent.*;

public class newSingleThreadExecutor {

    static class RunnableTask implements Runnable {

        @Override
        public void run() {
            System.out.println("【Runnable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    static class CallableTask implements Callable {

        @Override
        public String call() throws Exception {
            System.out.println("【Callable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "【Callable】" + Thread.currentThread().getName() + "执行以完成！";
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService pool = Executors.newSingleThreadExecutor();
		// 通过execute执行Runnable
        pool.execute(new RunnableTask());
		// 通过submit提交Runnable
        pool.submit(new CallableTask()); // 一般不用
        // 通过submit提交Callable
        Future ft = pool.submit(new CallableTask());
        Thread.sleep(10);
        System.out.println(ft.get()); // 获取返回结果

        // 关闭线程池
        pool.shutdown();
    }
}
```

结果：

```java
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1执行以完成！
```



### 2、execute() 和 submit()

`pool.execute(new TargetTask())`和`pool.submit(new TargetTask())`都是用于向线程池提交任务的方法，但它们在某些方面有所区别。

1. **返回值**：`execute()`方法没有返回值，而`submit()`方法返回一个`Future`对象，可以通过该对象获取任务的执行结果或取消任务。
2. **异常处理**：当任务执行过程中出现异常时，`execute()`方法无法捕获异常，而`submit()`方法可以通过`Future`对象的`get()`方法捕获并处理异常。
3. **任务类型**：`execute()`方法接受`Runnable`类型的任务，而`submit()`方法既可以接受`Runnable`类型的任务，也可以接受`Callable`类型的任务。`Runnable`是一个无返回结果的任务，而`Callable`是一个具有返回结果的任务。
4. **执行结果**：`execute()`方法无法获取任务的执行结果，因为它没有返回值，而`submit()`方法可以通过`Future`对象的`get()`方法获取任务的执行结果。

综上所述，如果你只关心任务的执行，而不需要获取返回结果或处理异常，可以选择使用`execute()`方法。如果你需要获取任务的执行结果或处理异常，或者想提交一个带返回值的任务，可以选择使用`submit()`方法。

### 3、shutdown() 和 shutdownNow()

> （2）**shutdown()**：执行shutdown()方法后，线程池状态变为**SHUTDOWN**，此时线程池将拒绝新任务，不能再往线程池中添加新任务，否则会抛出RejectedExecutionException异常。此时，**线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成才会退出**。
>
> （1）**shutdownNow()**：执行shutdownNow()方法后，线程池状态会立刻变成**STOP**，**并试图停止所有正在执行的线程**，并且不再处理还在阻塞队列中等待的任务，**会返回那些未执行的任务**。

### 4、newFixedThreadPool创建“固定数量的线程池”

> **特点**：
>
> （1）如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量。
>
> （2）线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
>
> （3）在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）。
>
> **使用场景**：**CPU密集型**
>
> 需要任务长期执行的场景。“固定数量的线程池”的线程数能够比较稳定地保证一个数，能够避免频繁回收线程和创建线程，故适用于处理**CPU密集型**的任务，在CPU被工作线程长时间占用的情况下，能确保尽可能少地分配线程。
>
> **弊端**：
>
> 内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽。

```java
// 将newSingleThreadExecutor()修改为newFixedThreadPool(2)
ExecutorService pool = Executors.newFixedThreadPool(2);
```

结果如下：注意 **thread-2**

```java
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-2正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1执行以完成！
```

### 5、newCachedThreadPool创建“可缓存线程池”

> 该方法用于创建一个“可缓存线程池”，如果线程池内的某些线程无事可干成为空闲线程，“可缓存线程池”可灵活回收这些空闲线程。
>
> **特点**：
>
> （1）**线程创建**：在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务。
>
> （2）**线程数量**：此线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
>
> （3）**线程回收**：如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程。
>
> **适应场景**：
>
> 需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景。“可缓存线程池”的线程数量不固定，只要有空闲线程就会被回收；接收到的新异步任务执行目标，查看是否有线程处于空闲状态，如果没有就直接创建新的线程。
>
> **弊端**：
>
> 线程池没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能会因创建线程过多而导致资源耗尽。

```java
// 将newFixedThreadPool(2)newCachedThreadPool()
ExecutorService pool = Executors.newCachedThreadPool();
```

结果：

```jav
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-2正在执行中！
【Callable】pool-1-thread-3正在执行中！
【Callable】pool-1-thread-3执行以完成！
```

### 6、newScheduledThreadPool创建“可调度线程池”

> 该方法用于创建一个“可调度线程池”，即一个提供“延时”和“周期性”任务调度功能的ScheduledExecutorService类型的线程池。
>
> **适应场景**：
>
> 周期性地执行任务的场景。Spring Boot中的任务调度器，底层借助了JUC的ScheduleExecutorService“可调度线程池”实现，并且可以通过@Configuration配置类型的Bean。

注意：获取的使**ScheduledExecutorService**实例而不是**ExecutorService**

```java
    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(2);
        scheduled.scheduleAtFixedRate(new RunnableTask(),0,500,TimeUnit.MILLISECONDS);
        scheduled.scheduleWithFixedDelay(new RunnableTask(),0,500,TimeUnit.MILLISECONDS);
        Thread.sleep(10);
        // 关闭线程池
        scheduled.shutdown();
    }
```

结果：

```java
【Runnable】pool-1-thread-2正在执行中！
【Runnable】pool-1-thread-1正在执行中！
```

### 7、scheduleAtFixedRate() 和 scheduleWithFixedDelay()

```java
public ScheduledFuture<?> scheduleAtFixedRate(
	Runnable command,	// 异步任务 target 执行目标实例
	long initialDelay,	// 首次执行延时
	long period,		// 两次开始执行最小间隔时间
	TimeUnit unit		// 所设置的时间的计时单位
);

public ScheduledFuture<?> scheduleWithFixedDelay(
    Runnable command,	// 异步任务 target 执行目标实例
	long initialDelay,	// 首次执行延时
	long delay,			// 前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）
	TimeUnit unit		// 所设置的时间的计时单位
);
```

### 8、总结

> 以上为Executors中4个主要的快捷创建线程池的方法。为何JUC要提供工厂方法呢？原因是使用ThreadPoolExecutor、ScheduledThreadPoolExecutor构造器创建普通线程池、可调度线程池比较复杂，这些构造器会涉及大量的复杂参数。尽管Executors的工厂方法使用方便，但是在生产场景中被很多企业（尤其是大厂）的开发规范所禁用。

## 四、线程池的标准创建方式

> 大部分企业的开发规范都会禁止使用快捷线程池（具体原因稍后介绍），要求通过标准构造器ThreadPoolExecutor去构造工作线程池。Executors工厂类中创建线程池的快捷工厂方法实际上是调用ThreadPoolExecutor（定时任务使用ScheduledThreadPoolExecutor）线程池的构造方法完成的。
>
> ThreadPoolExecutor构造方法有多个重载版本，其中一个比较重要的构造器如下：

```java
public ThreadPoolExecutor(
    int corePoolSize,					// 核心线程数，即使线程空闲（Idle），也不会回收
    int maximumPoolSize,				// 线程数的上限
    long keepAliveTime, TimeUnit unit,	// 线程最大空闲（Idle）时长
    BlockingQueue<Runnable> workQueue,	// 任务的排队队列
    ThreadFactory threadFactory,		// 新线程的生成方式
    RejectedExecutionHandler handler	// 拒绝策略
)
```

### 1、核心和最大线程数

> 参数corePoolSize用于设置核心（Core）线程池数量，参数maximumPoolSize用于设置最大线程数量。线程池执行器将会根据corePoolSize和maximumPoolSize自动维护线程池中的工作线程，大致规则为：
>
> （1）当在线程池接收到新任务，并且当前工作线程数少于corePoolSize时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求，直到线程数达到corePoolSize。
>
> （2）如果当前工作线程数多于corePoolSize数量，但小于maximumPoolSize数量，那么仅当任务排队队列已满时才会创建新线程。通过设置corePoolSize和maximumPoolSize相同，可以创建一个固定大小的线程池。
>
> （3）当maximumPoolSize被设置为无界值（如Integer.MAX_VALUE）时，线程池可以接收任意数量的并发任务。
>
> （4）corePoolSize和maximumPoolSize不仅能在线程池构造时设置，也可以调用setCorePoolSize()和setMaximumPoolSize()两个方法进行动态更改。

### 2、BlockingQueue

> BlockingQueue（阻塞队列）的实例用于暂时接收到的异步任务，如果线程池的核心线程都在忙，那么所接收到的目标任务缓存在阻塞队列中。

### 3、keepAliveTime

> 线程构造器的keepAliveTime（空闲线程存活时间）参数用于设置池内线程最大Idle（空闲）时长（或者说保活时长），如果超过这个时间，默认情况下Idle、非Core线程会被回收。
>
> 如果池在使用过程中提交任务的频率变高，也可以调用方法setKeepAliveTime(long，TimeUnit)进行线程存活时间的动态调整，可以将时长延长。如果需要防止Idle线程被终止，可以将Idle时间设置为无限大，具体如下：	

```java
setKeepAliveTime(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
```

> 默认情况下，Idle超时策略仅适用于存在超过corePoolSize线程的情况。但若调用了allowCoreThreadTimeOut(boolean)方法，并且传入了参数true，则keepAliveTime参数所设置的Idle超时策略也将被应用于核心线程。

## 五、向线程池提交任务的两种方式

> 方式一：execute()

```java
// Executor 接口中的方法
void execute(Runnable command);
```

> 方式二：submit()

```java
// ExecutorService 接口中的方法
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```

> **区别**：
>
> （1）二者所接收的参数不一样
>
> Execute()方法只能接收Runnable类型的参数，而submit()方法可以接收Callable、Runnable两种类型的参数。Callable类型的任务是可以返回执行结果的，而Runnable类型的任务不可以返回执行结果。
>
> （2）submit()提交任务后会有返回值，而execute()没有
>
> execute()方法主要用于启动任务的执行，而任务的执行结果和可能的异常调用者并不关心。submit()方法也用于启动任务的执行，但是启动之后会返回Future对象，代表一个异步执行实例，可以通过该异步执行实例去获取结果。
>
> （3）submit()方便Exception处理
>
> execute()方法在启动任务执行后，任务执行过程中可能发生的异常调用者并不关心。而通过submit()方法返回的Future对象（异步执行实例），可以进行异步执行过程中的异常捕获。
>
> 注：Runnable不允许抛出异常，Callable允许抛出异常。
