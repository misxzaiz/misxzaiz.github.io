# Java线程池

参考资料：[《Java高并发核心编程（卷2）》](https://weread.qq.com/web/bookDetail/9b93254072456ac19b9a176)

[TOC]

## 一、基本概念

### 1、创建线程的成本：

> Java线程的创建非常昂贵，需要JVM和OS（操作系统）配合完成大量的工作：
>
> （1）内存：必须为线程堆栈分配和初始化大量内存块，其中包括至少1MB的栈内存；
>
> （2）系统：需要进行系统调用，以便在OS（操作系统）中创建和注册本地线程。

### 2、使用线程池的好处

> Java高并发应用频繁创建和销毁线程的操作是非常低效的，而且是不被编程规范所允许的。
>
> 线程池主要解决以下两个问题：
>
> （1）提高性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。
>
> （2）线程管理：每个Java线程池会保持一些基本的线程统计信息，如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步人物为进行高效调度。

## 二、JUC的线程池架构

> **JUC**就是java.util.concurrent工具包的简称，该工具包是从JDK 1.5开始加入JDK的，是用于完成**高并发**、**处理多线程**的一个工具包。
>
> 在多线程编程中，任务都是一些抽象且离散的工作单元，而线程是使任务异步执行的基本机制，为了简化这些复杂的**线程管理模式**，我们使用**线程池**来统一管理线程及任务分配。


图 JUC中线程池的类与接口的架构

![img](assets/epub_38103745_16)

### 1、Executor（接口）

> Executor是Java异步目标任务的“执行者”接口，其目标是**执行目标任务**。
>
> “执行者”Executor提供了execute()接口来**执行已提交的Runnable执行目标实例**。
>
> Executor作为执行者的角色，其目的是**提供一种将“任务提交者”与“任务执行者”分离开来的机制**。
>
> 它只包含一个**函数式方法**：

```java
void execute(Runnable command)
```



### 2、ExecutorService（接口）

> ExecutorService继承于Executor。
>
> 它是Java异步目标任务的“执行者服务接”口，**对外提供异步任务的接收服务**。
>
> ExecutorService提供了“**接收异步任务并转交给执行者**”的方法，如submit系列方法、invoke系列方法等，具体如下：

```java
// 向线程池提交单个异步任务
<T> Future<T> submit(Callable<T> task)
// 向线程池提交批量异步任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
```



### 3、AbstractExecutorService

> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的接口**提供默认实现**。



### 4、 ThreadPoolExecutor

> ThreadPoolExecutor就是大名鼎鼎的“线程池”实现类，它继承于AbstractExecutorService抽象类。
>
> ThreadPoolExecutor是JUC线程池的核心实现类。
>
> 线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控。



### 5、ScheduledExecutorService（接口）

> ScheduledExecutorService是一个接口，它继承于ExecutorService。它是一个可以完成“**延时**”和“**周期性**”任务的调度线程池接口，其功能和Timer/TimerTask类似。



### 6、ScheduledThreadPoolExecutor

> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提供了ScheduledExecutorService线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。
>
> ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。



### 7、Executors

> Executors是一个**静态工厂类**，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。



### 8、Timer（补充）

> 每个1秒输出一次

```java
    private static void extracted() {
        Timer timer = new Timer();
        TimerTask task = new TimerTask() {
            int count = 0;

            @Override
            public void run() {
                count++;
                System.out.println("输出信息 - 第 " + count + " 次");
            }
        };

        timer.scheduleAtFixedRate(task, 0, 1000);
    }
```

## 三、Executors的四种快捷创建线程的方法

> Java通过Executors工厂类提供4种快捷创建线程池的方法：

| 方法                                     | 说明                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| newSingleThreadExecutor()                | 创建只有一个线程的线程池                                     |
| newFixedThreadPool(int nThreads)         | 创建固定大小的线程池                                         |
| newCachedThreadPool()                    | 创建一个不限制线程数量的线程池，任何提交的任务都将立即执行，但是空闲线程会得到及时回收 |
| newSingleThreadScheduledExecutor()       | 创建一个可调度的线程池，池内仅含一个线程                     |
| newScheduledThreadPool(int corePoolSize) | 创建一个可调度的线程池，池内仅含 corePoolSize 个线程         |

### 1、newSingleThreadExecutor创建“单线程化线程池”

> 该方法用于创建一个“单线程化线程池”，也就是只有一个线程的线程池，所创建的线程池用唯一的工作线程来执行任务，使用此方法创建的线程池能**保证所有任务按照指定顺序（如FIFO）执行**。
>
> 特点：
>
> （1）单线程化的线程池中的任务是**按照提交的次序顺序执行**的。
>
> （2）池中的唯一线程的**存活时间是无限的**。
>
> （3）当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其**阻塞队列是无界的**。

```java
package org.example.demo.executor;

import java.util.concurrent.*;

public class newSingleThreadExecutor {

    static class RunnableTask implements Runnable {

        @Override
        public void run() {
            System.out.println("【Runnable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    static class CallableTask implements Callable {

        @Override
        public String call() throws Exception {
            System.out.println("【Callable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "【Callable】" + Thread.currentThread().getName() + "执行以完成！";
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService pool = Executors.newSingleThreadExecutor();
		// 通过execute执行Runnable
        pool.execute(new RunnableTask());
		// 通过submit提交Runnable
        pool.submit(new CallableTask()); // 一般不用
        // 通过submit提交Callable
        Future ft = pool.submit(new CallableTask());
        Thread.sleep(10);
        System.out.println(ft.get()); // 获取返回结果

        // 关闭线程池
        pool.shutdown();
    }
}
```

结果：

```java
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1执行以完成！
```



### 2、execute() 和 submit()

`pool.execute(new TargetTask())`和`pool.submit(new TargetTask())`都是用于向线程池提交任务的方法，但它们在某些方面有所区别。

1. **返回值**：`execute()`方法没有返回值，而`submit()`方法返回一个`Future`对象，可以通过该对象获取任务的执行结果或取消任务。
2. **异常处理**：当任务执行过程中出现异常时，`execute()`方法无法捕获异常，而`submit()`方法可以通过`Future`对象的`get()`方法捕获并处理异常。
3. **任务类型**：`execute()`方法接受`Runnable`类型的任务，而`submit()`方法既可以接受`Runnable`类型的任务，也可以接受`Callable`类型的任务。`Runnable`是一个无返回结果的任务，而`Callable`是一个具有返回结果的任务。
4. **执行结果**：`execute()`方法无法获取任务的执行结果，因为它没有返回值，而`submit()`方法可以通过`Future`对象的`get()`方法获取任务的执行结果。

综上所述，如果你只关心任务的执行，而不需要获取返回结果或处理异常，可以选择使用`execute()`方法。如果你需要获取任务的执行结果或处理异常，或者想提交一个带返回值的任务，可以选择使用`submit()`方法。

### 3、shutdown() 和 shutdownNow()

> （2）**shutdown()**：执行shutdown()方法后，线程池状态变为**SHUTDOWN**，此时线程池将拒绝新任务，不能再往线程池中添加新任务，否则会抛出RejectedExecutionException异常。此时，**线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成才会退出**。
>
> （1）**shutdownNow()**：执行shutdownNow()方法后，线程池状态会立刻变成**STOP**，**并试图停止所有正在执行的线程**，并且不再处理还在阻塞队列中等待的任务，**会返回那些未执行的任务**。

### 4、newFixedThreadPool创建“固定数量的线程池”

> **特点**：
>
> （1）如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量。
>
> （2）线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
>
> （3）在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）。
>
> **使用场景**：**CPU密集型**
>
> 需要任务长期执行的场景。“固定数量的线程池”的线程数能够比较稳定地保证一个数，能够避免频繁回收线程和创建线程，故适用于处理**CPU密集型**的任务，在CPU被工作线程长时间占用的情况下，能确保尽可能少地分配线程。
>
> **弊端**：
>
> 内部使用无界队列来存放排队任务，当大量任务超过线程池最大容量需要处理时，队列无限增大，使服务器资源迅速耗尽。

```java
// 将newSingleThreadExecutor()修改为newFixedThreadPool(2)
ExecutorService pool = Executors.newFixedThreadPool(2);
```

结果如下：注意 **thread-2**

```java
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-2正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1执行以完成！
```

### 5、newCachedThreadPool创建“可缓存线程池”

> 该方法用于创建一个“可缓存线程池”，如果线程池内的某些线程无事可干成为空闲线程，“可缓存线程池”可灵活回收这些空闲线程。
>
> **特点**：
>
> （1）**线程创建**：在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务。
>
> （2）**线程数量**：此线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
>
> （3）**线程回收**：如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程。
>
> **适应场景**：
>
> 需要快速处理突发性强、耗时较短的任务场景，如Netty的NIO处理场景、REST API接口的瞬时削峰场景。“可缓存线程池”的线程数量不固定，只要有空闲线程就会被回收；接收到的新异步任务执行目标，查看是否有线程处于空闲状态，如果没有就直接创建新的线程。
>
> **弊端**：
>
> 线程池没有最大线程数量限制，如果大量的异步任务执行目标实例同时提交，可能会因创建线程过多而导致资源耗尽。

```java
// 将newFixedThreadPool(2)newCachedThreadPool()
ExecutorService pool = Executors.newCachedThreadPool();
```

结果：

```jav
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-2正在执行中！
【Callable】pool-1-thread-3正在执行中！
【Callable】pool-1-thread-3执行以完成！
```

### 6、newScheduledThreadPool创建“可调度线程池”

> 该方法用于创建一个“可调度线程池”，即一个提供“延时”和“周期性”任务调度功能的ScheduledExecutorService类型的线程池。
>
> **适应场景**：
>
> 周期性地执行任务的场景。Spring Boot中的任务调度器，底层借助了JUC的ScheduleExecutorService“可调度线程池”实现，并且可以通过@Configuration配置类型的Bean。

注意：获取的使**ScheduledExecutorService**实例而不是**ExecutorService**

```java
    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(2);
        scheduled.scheduleAtFixedRate(new RunnableTask(),0,500,TimeUnit.MILLISECONDS);
        scheduled.scheduleWithFixedDelay(new RunnableTask(),0,500,TimeUnit.MILLISECONDS);
        Thread.sleep(10);
        // 关闭线程池
        scheduled.shutdown();
    }
```

结果：

```java
【Runnable】pool-1-thread-2正在执行中！
【Runnable】pool-1-thread-1正在执行中！
```

### 7、scheduleAtFixedRate() 和 scheduleWithFixedDelay()

```java
public ScheduledFuture<?> scheduleAtFixedRate(
	Runnable command,	// 异步任务 target 执行目标实例
	long initialDelay,	// 首次执行延时
	long period,		// 两次开始执行最小间隔时间
	TimeUnit unit		// 所设置的时间的计时单位
);

public ScheduledFuture<?> scheduleWithFixedDelay(
    Runnable command,	// 异步任务 target 执行目标实例
	long initialDelay,	// 首次执行延时
	long delay,			// 前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）
	TimeUnit unit		// 所设置的时间的计时单位
);
```

### 8、总结

> 以上为Executors中4个主要的快捷创建线程池的方法。为何JUC要提供工厂方法呢？原因是使用ThreadPoolExecutor、ScheduledThreadPoolExecutor构造器创建普通线程池、可调度线程池比较复杂，这些构造器会涉及大量的复杂参数。尽管Executors的工厂方法使用方便，但是在生产场景中被很多企业（尤其是大厂）的开发规范所禁用。

## 四、线程池的标准创建方式（ThreadPoolExecutor）

> 大部分企业的开发规范都会禁止使用快捷线程池（具体原因稍后介绍），要求通过标准构造器ThreadPoolExecutor去构造工作线程池。Executors工厂类中创建线程池的快捷工厂方法实际上是调用ThreadPoolExecutor（定时任务使用ScheduledThreadPoolExecutor）线程池的构造方法完成的。
>
> ThreadPoolExecutor构造方法有多个重载版本，其中一个比较重要的构造器如下：

```java
public ThreadPoolExecutor(
    int corePoolSize,					// 核心线程数，即使线程空闲（Idle），也不会回收
    int maximumPoolSize,				// 线程数的上限
    long keepAliveTime, TimeUnit unit,	// 线程最大空闲（Idle）时长
    BlockingQueue<Runnable> workQueue,	// 任务的排队队列
    ThreadFactory threadFactory,		// 新线程的生成方式
    RejectedExecutionHandler handler	// 拒绝策略
)
```

### 1、核心和最大线程数

> 参数corePoolSize用于设置核心（Core）线程池数量，参数maximumPoolSize用于设置最大线程数量。线程池执行器将会根据corePoolSize和maximumPoolSize自动维护线程池中的工作线程，大致规则为：
>
> （1）当在线程池接收到新任务，并且当前工作线程数少于corePoolSize时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求，直到线程数达到corePoolSize。
>
> （2）如果当前工作线程数多于corePoolSize数量，但小于maximumPoolSize数量，那么仅当任务排队队列已满时才会创建新线程。通过设置corePoolSize和maximumPoolSize相同，可以创建一个固定大小的线程池。
>
> （3）当maximumPoolSize被设置为无界值（如Integer.MAX_VALUE）时，线程池可以接收任意数量的并发任务。
>
> （4）corePoolSize和maximumPoolSize不仅能在线程池构造时设置，也可以调用setCorePoolSize()和setMaximumPoolSize()两个方法进行动态更改。

### 2、BlockingQueue

> BlockingQueue（阻塞队列）的实例用于暂时接收到的异步任务，如果线程池的核心线程都在忙，那么所接收到的目标任务缓存在阻塞队列中。

### 3、keepAliveTime

> 线程构造器的keepAliveTime（空闲线程存活时间）参数用于设置池内线程最大Idle（空闲）时长（或者说保活时长），如果超过这个时间，默认情况下Idle、非Core线程会被回收。
>
> 如果池在使用过程中提交任务的频率变高，也可以调用方法setKeepAliveTime(long，TimeUnit)进行线程存活时间的动态调整，可以将时长延长。如果需要防止Idle线程被终止，可以将Idle时间设置为无限大，具体如下：	

```java
setKeepAliveTime(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
```

> 默认情况下，Idle超时策略仅适用于存在超过corePoolSize线程的情况。但若调用了allowCoreThreadTimeOut(boolean)方法，并且传入了参数true，则keepAliveTime参数所设置的Idle超时策略也将被应用于核心线程。

## 五、向线程池提交任务的两种方式

> 在ThreadPoolExecutor类的实现中，内部核心的任务提交方法是execute()方法，虽然用户程序通过submit()也可以提交任务，但是实际上submit()方法中最终调用的还是execute()方法。

> 方式一：execute()

```java
// Executor 接口中的方法
void execute(Runnable command);
```

> 方式二：submit()

```java
// ExecutorService 接口中的方法
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```

> **区别**：
>
> （1）二者所接收的参数不一样
>
> Execute()方法只能接收Runnable类型的参数，而submit()方法可以接收Callable、Runnable两种类型的参数。Callable类型的任务是可以返回执行结果的，而Runnable类型的任务不可以返回执行结果。
>
> （2）submit()提交任务后会有返回值，而execute()没有
>
> execute()方法主要用于启动任务的执行，而任务的执行结果和可能的异常调用者并不关心。submit()方法也用于启动任务的执行，但是启动之后会返回Future对象，代表一个异步执行实例，可以通过该异步执行实例去获取结果。
>
> （3）submit()方便Exception处理
>
> execute()方法在启动任务执行后，任务执行过程中可能发生的异常调用者并不关心。而通过submit()方法返回的Future对象（异步执行实例），可以进行异步执行过程中的异常捕获。
>
> 注：Runnable不允许抛出异常，Callable允许抛出异常。

### 1、通过submit()返回的Future对象获取结果

> submit()方法自身并不会传递结果，而是返回一个Future异步执行实例，处理过程的结果被包装到Future实例中，调用者可以通过Future.get()方法获取异步执行的结果。

### 2、通过submit()返回的Future对象捕获异常

> submit()方法自身并不会传递异常，处理过程中的异常都被包装到Future实例中，**调用者在调用Future.get()方法获取执行结果时，可以捕获异步执行过程中抛出的受检异常和运行时异常，并进行对应的业务处理**。

## 六、线程池的任务调度流程

> 线程池的任务调度流程（包含接收新任务和执行下一个任务）大致如下：
>
> （1）如果当前工作线程数量小于核心线程数量，执行器总是优先创建一个任务线程，而不是从线程队列中获取一个空闲线程。
>
> （2）如果线程池中总的任务数量大于核心线程池数量，新接收的任务将被加入阻塞队列中，一直到阻塞队列已满。在核心线程池数量已经用完、阻塞队列没有满的场景下，线程池不会为新任务创建一个新线程。
>
> （3）当完成一个任务的执行时，执行器总是优先从阻塞队列中获取下一个任务，并开始执行，一直到阻塞队列为空，其中所有的缓存任务被取光。
>
> （4）在核心线程池数量已经用完、阻塞队列也已经满了的场景下，如果线程池接收到新的任务，将会为新任务创建一个线程（非核心线程），并且立即开始执行新任务。
>
> （5）在核心线程都用完、阻塞队列已满的情况下，一直会创建新线程去执行新任务，直到池内的线程总数超出maximumPoolSize。如果线程池的线程总数超过maximumPoolSize，线程池就会拒绝接收任务，当新任务过来时，会为新任务执行拒绝策略。

![img](assets/epub_38103745_18)

> 在创建线程池时，如果线程池的参数（如核心线程数量、最大线程数量、BlockingQueue等）配置得不合理，就会出现任务不能被正常调度的问题。

```java
package org.example.demo.executor;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolDemo {
    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                1,
                100,
                100,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(100));
        for (int i = 0; i < 5; i++) {
            final int taskIndex = i;
            executor.execute(() -> {
                System.out.println(taskIndex);
                try {
                    // 极端测试：无限制休眠
                    Thread.sleep(Long.MAX_VALUE);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            });
        }
        while (true) {
            System.out.println("工作任务数量：" + executor.getActiveCount() + "\n" +
                    "总的任务数量：" + executor.getTaskCount());
            Thread.sleep(1000);
        }
    }
}
```

结果：

```java
0
工作任务数量：1
总的任务数量：5
工作任务数量：1
总的任务数量：5
工作任务数量：1
总的任务数量：5
```

问题：

> 以上示例创建了最大线程数量maximumPoolSize为100的线程池，仅仅向其中提交了5个任务。理论上，这5个任务都会被执行到，奇怪的是示例中只有1个任务在执行，其他的4个任务都在等待。其他任务被加入到了阻塞队列中，需要等pool-1-thread-1线程执行完第一个任务后，才能依次从阻塞队列取出执行。但是，实例中的第一个任务是一个永远也没有办法完成的任务，所以其他的4个任务只能永远在阻塞队列中等待着。由于参数配置得不合理，因此出现了以上的奇怪现象。

> 为什么会出现上面的奇怪现象呢？因为例子中的corePoolSize为1，阻塞队列的大小为100，按照线程创建的规则，需要等阻塞队列已满，才会去创建新的线程。例子中加入了5个任务，阻塞队列大小为4（<100），所以线程池的调度器不会去创建新的线程，后面的4个任务只能等待。

以上示例的目的是传递两个知识点：

> （1）核心和最大线程数量、BlockingQueue队列等参数如果配置得不合理，可能会造成异步任务得不到预期的并发执行，造成严重的排队等待现象。
>
> （2）线程池的调度器创建线程的一条重要的规则是：在corePoolSize已满之后，还需要等阻塞队列已满，才会去创建新的线程。

## 七、ThreadFactory（线程工厂）

> ThreadFactory是Java线程工厂接口，这是一个非常简单的接口，具体如下：

```java
package java.util.concurrent;

public interface ThreadFactory {
    // 唯一的方法，创建一个新线程
    Thread newThread(Runnable r);
}
```

> 在调用ThreadFactory的唯一方法newThread()创建新线程时，可以更改所创建的新线程的名称、线程组、优先级、守护进程状态等。
>
> 如果newThread()的返回值为null，表示线程工厂未能成功创建线程，线程池可能无法执行任何任务。

> 使用Executors创建新的线程池时，也可以基于ThreadFactory（线程工厂）创建，在创建新线程池时可以指定将要使用的ThreadFactory实例。
>
> 只不过，如果没有指定的话，就会使用Executors.defaultThreadFactory默认实例。
>
> 使用默认的线程工厂实例所创建的线程全部位于同一个ThreadGroup（线程组）中，具有相同的NORM_PRIORITY（优先级为5），而且都是非守护进程状态。

### 1、ThreadFactory 和 Executors

> Executors为**线程池**工厂类，用于快捷创建线程池（Thread Pool）；
>
> ThreadFactory为**线程**工厂类，用于创建线程（Thread）。

### 2、基于自定义的ThreadFactory实例创建线程池

> 基于自定义的ThreadFactory实例创建线程池，首先需要实现一个ThreadFactory类，实现其唯一的抽象方法newThread(Runnable)。

```java
package org.example.demo.executor;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

public class ThreadFactoryDemo {
    static public class SimpleThreadFactory implements ThreadFactory {
        static AtomicInteger threadNo = new AtomicInteger();

        @Override
        public Thread newThread(Runnable target) {
            String threadName = "simpleThread-" + threadNo.get();
            threadNo.incrementAndGet();
            // 设置线程名称和异步执行目标
            Thread thread = new Thread(target, threadName);
            // 设置为守护线程
            thread.setDaemon(true);
            return thread;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(2, new SimpleThreadFactory());
        for (int i = 0; i < 5; i++) {
            pool.submit(new RunnableTask());
        }
        Thread.sleep(100);
        pool.shutdown();
    }

    static class RunnableTask implements Runnable {

        @Override
        public void run() {
            System.out.println("【Runnable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

结果：

```java
【Runnable】simpleThread-1正在执行中！
【Runnable】simpleThread-0正在执行中！
【Runnable】simpleThread-0正在执行中！
【Runnable】simpleThread-1正在执行中！
【Runnable】simpleThread-1正在执行中！
```

> 从输出结果看到，新建池中的线程名称都不是默认的pool-1-thread-1形式，是线程工厂更改后的形式。

## 八、任务阻塞队列

> Java中的阻塞队列（BlockingQueue）与普通队列相比有一个重要的特点：在阻塞队列为空时会阻塞当前线程的元素获取操作。
>
> 具体来说，在一个线程从一个空的阻塞队列中获取元素时线程会被阻塞，直到阻塞队列中有了元素；当队列中有元素后，被阻塞的线程会自动被唤醒（唤醒过程不需要用户程序干预）。
>
> Java线程池使用BlockingQueue实例暂时接收到的异步任务，BlockingQueue是JUC包的一个超级接口。

> 以下是 BlockingQueue 的常用实现类：

### 1、ArrayBlockingQueue

是一个数组实现的有界阻塞队列（有界队列），队列中的元素按FIFO排序。ArrayBlockingQueue在创建时必须设置大小，接收的任务超出corePoolSize数量时，任务被缓存到该阻塞队列中，任务缓存的数量只能为创建时设置的大小，若该阻塞队列已满，则会为新的任务创建线程，直到线程池中的线程总数大于maximumPoolSize。

### 2、LinkedBlockingQueue

是一个基于链表实现的阻塞队列，按FIFO排序任务，可以设置容量（有界队列），不设置容量则默认使用Integer.Max_VALUE作为容量（无界队列）。该队列的吞吐量高于ArrayBlockingQueue。如果不设置LinkedBlockingQueue的容量（无界队列），当接收的任务数量超出corePoolSize时，则新任务可以被无限制地缓存到该阻塞队列中，直到资源耗尽。

有两个快捷创建线程池的工厂方法Executors.newSingleThreadExecutor和Executors.newFixedThreadPool使用了这个队列，并且都没有设置容量（无界队列）。

### 3、PriorityBlockingQueue

是具有优先级的无界队列。

### 4、DelayQueue

这是一个无界阻塞延迟队列，底层基于PriorityBlockingQueue实现，队列中每个元素都有过期时间，当从队列获取元素（元素出队）时，只有已经过期的元素才会出队，队列头部的元素是过期最快的元素。

快捷工厂方法Executors.newScheduledThreadPool所创建的线程池使用此队列。

### 5、SynchronousQueue

（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程的调用移除操作，否则插入操作一直处于阻塞状态，其吞吐量通常高于LinkedBlockingQueue。

快捷工厂方法Executors.newCachedThreadPool所创建的线程池使用此队列。与前面的队列相比，这个队列比较特殊，它不会保存提交的任务，而是直接新建一个线程来执行新来的任务。

## 九、调度器的钩子方法

> ThreadPoolExecutor线程池调度器为每个任务执行前后都提供了钩子方法。
>
> beforeExecute和afterExecute两个方法在每个任务执行前后被调用，如果钩子（回调方法）引发异常，内部工作线程可能失败并突然终止。
>
> ThreadPoolExecutor类提供了三个钩子方法（空方法），这三个钩子方法一般用作被子类重写，具体如下：

```java
// 任务执行之前的钩子方法（前钩子）
protected void beforeExecute(Thread t, Runnable r) {}
// 任务执行之后的钩子方法（后钩子）
protected void afterExecute(Runnable r, Throwable t) {}
// 线程池终止时的钩子方法（停止钩子）
protected void terminated() {}
```

### 1、beforeExecute

异步任务执行之前的钩子方法线程池工作线程在异步执行目标实例（如Runnable实例）前调用此钩子方法。

此方法仍然由执行任务的工作线程调用。

默认实现不执行任何操作，但可以在子类中对其进行自定义。

此方法由执行目标实例的工作线程调用，**可用于重新初始化ThreadLocal线程本地变量实例、更新日志记录、开始计时统计、更新上下文变量等**。

### 2、afterExecute

异步任务执行之后的钩子方法线程池工作线程在异步执行目标实例后调用此钩子方法。

此方法仍然由执行任务的工作线程调用。

此钩子方法的默认实现不执行任何操作，可以在调度器子类中对其进行自定义。

此方法由执行目标实例的工作线程调用，**可用于清除ThreadLocal线程本地变量、更新日志记录、收集统计信息、更新上下文变量等**。

### 3、terminated

线程池终止时的钩子方法terminated钩子方法在Executor终止时调用，默认实现不执行任何操作。

### 4、使用实例

```java
package org.example.demo.executor;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class HookDemo {
    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(
                2, 4, 60, TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(2)) {
            @Override
            protected void terminated() {
                System.out.println("调度器已终止！");
            }

            @Override
            protected void beforeExecute(Thread t, Runnable target) {
                System.out.println(target + "前钩被执行");
                // 记录开始执行时间
                System.out.println("开始执行时间" + System.currentTimeMillis());
                super.beforeExecute(t, target);
            }

            @Override
            protected void afterExecute(Runnable target, Throwable t) {
                super.afterExecute(target, t);
                // 记录结束执行时间
                System.out.println("结束执行时间" + System.currentTimeMillis());
                System.out.println(target + "后钩被执行");
                // 清空本地变量
            }
        };
        for (int i = 0; i < 5; i++) {
            pool.submit(new ThreadFactoryDemo.RunnableTask());
        }
        Thread.sleep(100);
        pool.shutdown();
    }

    static class RunnableTask implements Runnable {

        @Override
        public void run() {
            System.out.println("【Runnable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

## 十、线程池的拒绝策略

> 在线程池的任务缓存队列为有界队列（有容量限制的队列）的时候，如果队列满了，提交任务到线程池的时候就会被拒绝。
>
> 总体来说，任务被拒绝有两种情况：
>
> （1）线程池已经被关闭。
>
> （2）工作队列已满且maximumPoolSize已满。
>
> 无论以上哪种情况任务被拒绝，线程池都会调用RejectedExecutionHandler实例的rejectedExecution方法。
>
> RejectedExecutionHandler是拒绝策略的接口，JUC为该接口提供了以下几种实现：
>
> AbortPolicy：拒绝策略。
>
> DiscardPolicy：抛弃策略。
>
> DiscardOldestPolicy：抛弃最老任务策略。
>
> CallerRunsPolicy：调用者执行策略。
>
> 自定义策略。

### 1、AbortPolicy

使用该策略时，如果线程池队列满了，新任务就会被拒绝，并且抛出RejectedExecutionException异常。该策略是线程池默认的拒绝策略。

### 2、DiscardPolicy

该策略是AbortPolicy的Silent（安静）版本，如果线程池队列满了，新任务就会直接被丢掉，并且不会有任何异常抛出。

### 3、DiscardOldestPolicy

抛弃最老任务策略，也就是说如果队列满了，就会将最早进入队列的任务抛弃，从队列中腾出空间，再尝试加入队列。因为队列是队尾进队头出，队头元素是最老的，所以每次都是移除队头元素后再尝试入队。

### 4、CallerRunsPolicy

调用者执行策略。在新任务被添加到线程池时，如果添加失败，那么提交任务线程会自己去执行该任务，不会使用线程池中的线程去执行新任务。

> 在以上4种内置策略中，线程池默认的拒绝策略为AbortPolicy，如果提交的任务被拒绝，线程池就会抛出RejectedExecutionException异常，该异常是非受检异常（运行时异常），很容易忘记捕获。如果关心任务被拒绝的事件，需要在提交任务时捕获RejectedExecutionException异常。

### 5、自定义策略

如果以上拒绝策略都不符合需求，那么可自定义一个拒绝策略，实现RejectedExecutionHandler接口的rejectedExecution方法即可。

```java
     package com.crazymakercircle.multithread.basic.create3;
     // 省略import
     public class CreateThreadPoolDemo
     {
         //一个简单的线程工厂
         static public class SimpleThreadFactory implements ThreadFactory
         {
         //为了节约篇幅，省略重复内容
     }
     
         //自定义拒绝策略
         public static class CustomIgnorePolicy
                          implements RejectedExecutionHandler
         {
             public void rejectedExecution(Runnable r, ThreadPoolExecutor e)
             {
                 // 可做日志记录等
                 Print.tco(r + " rejected; " +
                          " - getTaskCount: " + e.getTaskCount());
             }
         }
     
         @org.junit.Test
         public void testCustomIgnorePolicy()
         {
             int corePoolSize = 2;          //核心线程数
             int maximumPoolSize = 4;       //最大线程数
             long keepAliveTime = 10;
             TimeUnit unit = TimeUnit.SECONDS;
             //最大排队任务数
             BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);
             //线程工厂
             ThreadFactory threadFactory = new SimpleThreadFactory();
             //拒绝和异常处理策略
             RejectedExecutionHandler policy = new CustomIgnorePolicy();
             ThreadPoolExecutor pool = new ThreadPoolExecutor(
                     corePoolSize,
                     maximumPoolSize,
                     keepAliveTime, unit,
                     workQueue,
                     threadFactory,
                     policy);
     
             // 预启动所有核心线程
             pool.prestartAllCoreThreads();
             for (int i = 1; i <= 10; i++)
             {
                 pool.execute(new TargetTask());
             }
             //等待10秒
             sleepSeconds(10);
             Print.tco("关闭线程池");
             pool.shutdown();
         }
         // 省略其他
     }
```

```java
     [main]：创建一个线程，名称为：simpleThread-1
     [main]：创建一个线程，名称为：simpleThread-2
     [main]：创建一个线程，名称为：simpleThread-3
     [simpleThread-1]：任务：task-1 doing
     [simpleThread-2]：任务：task-2 doing
     [main]：创建一个线程，名称为：simpleThread-4
     [simpleThread-3]：任务：task-3 doing
     [simpleThread-4]：任务：task-6 doing
     [main]：TargetTask{task-7} rejected;  - getTaskCount: 6
     [main]：TargetTask{task-8} rejected;  - getTaskCount: 6
     [main]：TargetTask{task-9} rejected;  - getTaskCount: 6
     [main]：TargetTask{task-10} rejected;  - getTaskCount: 6
     [simpleThread-1]：task-1 运行结束.
     [simpleThread-2]：task-2 运行结束.
     [simpleThread-1]：任务：task-4 doing
     [simpleThread-2]：任务：task-5 doing
     [simpleThread-2]：task-5 运行结束.
     [simpleThread-4]：task-6 运行结束.
     [simpleThread-3]：task-3 运行结束.
     [simpleThread-1]：task-4 运行结束.
     [main]：关闭线程池
```

## 十一、线程池优雅关闭（需要再看书）

> 一般情况下，线程池启动后建议手动关闭。在介绍线程池的优雅关闭之前，我们先了解一下线程池的状态。线程池总共存在5种状态，定义在ThreadPoolExecutor类中，具体代码如下：

```java
     package java.util.concurrent;
     // 省略import
     public class ThreadPoolExecutor extends AbstractExecutorService {
          // runState is stored in the high-order bits
         private static final int RUNNING   		= -1 << COUNT_BITS;
         private static final int SHUTDOWN          =  0 << COUNT_BITS;
         private static final int STOP              =  1 << COUNT_BITS;
         private static final int TIDYING           =  2 << COUNT_BITS;
         private static final int TERMINATED        =  3 << COUNT_BITS;
         // 省略其他
     }
```

线程池的5种状态具体如下：

（1）RUNNING：线程池创建之后的初始状态，这种状态下可以执行任务。

（2）SHUTDOWN：该状态下线程池不再接受新任务，但是会将工作队列中的任务执行完毕。

（3）STOP：该状态下线程池不再接受新任务，也不会处理工作队列中的剩余任务，并且将会中断所有工作线程。

（4）TIDYING：该状态下所有任务都已终止或者处理完成，将会执行terminated()钩子方法。

（5）TERMINATED：执行完terminated()钩子方法之后的状态。

线程池的状态转换规则为：

（1）线程池创建之后状态为RUNNING。

（2）执行线程池的shutdown()实例方法，会使线程池状态从RUNNING转变为SHUTDOWN。

（3）执行线程池的shutdownNow()实例方法，会使线程池状态从RUNNING转变为STOP。

（4）当线程池处于SHUTDOWN状态时，执行其shutdownNow()方法会将其状态转变为STOP。

（5）等待线程池的所有工作线程停止，工作队列清空之后，线程池状态会从STOP转变为TIDYING。

（6）执行完terminated()钩子方法之后，线程池状态从TIDYING转变为TERMINATED。

### 1、优雅关闭线程池

大家可以结合shutdown()、shutdownNow()、awaitTermination()三个方法优雅地关闭一个线程池，大致分为以下几步：

（1）执行shutdown()方法，拒绝新任务的提交，并等待所有任务有序地执行完毕。

（2）执行awaitTermination(long timeout,TimeUnit unit)方法，指定超时时间，判断是否已经关闭所有任务，线程池关闭完成。

（3）如果awaitTermination()方法返回false，或者被中断，就调用shutDownNow()方法立即关闭线程池所有任务。

（4）补充执行awaitTermination(long timeout,TimeUnit unit)方法，判断线程池是否关闭完成。如果超时，就可以进入循环关闭，循环一定的次数（如1000次），不断关闭线程池，直到其关闭或者循环结束。

优雅地关闭线程池的参考代码如下：

```java
     package com.crazymakercircle.util;
     // 省略import
     public class ThreadUtil
     {
        public static void shutdownThreadPoolGracefully(
                                                           ExecutorService threadPool)
         {
             // 若已经关闭则返回
             if (!(threadPool instanceof ExecutorService) || 
                                                          threadPool.isTerminated())
             {
                 return;
             }
             try
             {
                 threadPool.shutdown();   //拒绝接受新任务
             } catch (SecurityException e)
             {
                 return;
             } catch (NullPointerException e)
             {
                 return;
             }
             try
             {
                 // 等待60秒，等待线程池中的任务完成执行
                 if (!threadPool.awaitTermination(60, TimeUnit.SECONDS))
                 {
                     // 调用 shutdownNow() 方法取消正在执行的任务
                     threadPool.shutdownNow();
                     // 再次等待60秒，如果还未结束，可以再次尝试，或者直接放弃
                     if (!threadPool.awaitTermination(60, TimeUnit.SECONDS))
                     {
                         System.err.println("线程池任务未正常执行结束");
                     }
                 }
             } catch (InterruptedException ie)
             {
                 // 捕获异常，重新调用 shutdownNow() 方法
                 threadPool.shutdownNow();
             }
             // 仍然没有关闭，循环关闭1000次，每次等待10毫秒
             if (!threadPool.isTerminated())
             {
                 try
                 {
                     for (int i = 0; i < 1000; i++)
                     {
                         if (threadPool.awaitTermination(10,TimeUnit.MILLISECONDS))
                         {
                             break;
                         }
                         threadPool.shutdownNow();
                     }
                 } catch (InterruptedException e)
                 {
                     System.err.println(e.getMessage());
                 } catch (Throwable e)
                 {
                     System.err.println(e.getMessage());
                 }
             }
         }
         // 省略不相干代码
     }
```

### 2、注册JVM钩子函数自动关闭线程池

如果使用了线程池，可以在JVM中注册一个钩子函数，在JVM进程关闭之前，由钩子函数自动将线程池优雅地关闭，以确保资源正常释放。

下面的例子使用JVM钩子函数关闭了一个定义在随书源码的ThreadUtil辅助类中用于执行定时、顺序任务的线程池，具体代码如下：

```java
     package com.crazymakercircle.util;
     // 省略import
     public class ThreadUtil
     {
     
         //懒汉式单例创建线程池：用于执行定时、顺序任务
         static class SeqOrScheduledTargetThreadPoolLazyHolder
         {
             //线程池：用于定时任务、顺序排队执行任务
             static final ScheduledThreadPoolExecutor EXECUTOR =
                             new ScheduledThreadPoolExecutor( 1,
                             new CustomThreadFactory("seq"));
     
             static
             {
                 //注册JVM关闭时的钩子函数
                 Runtime.getRuntime().addShutdownHook(
                                      new ShutdownHookThread("定时和顺序任务线程池",
                                      new Callable<Void>()
                         {
                             @Override
                             public Void call() throws Exception
                             {
                                 //优雅地关闭线程池
                                 shutdownThreadPoolGracefully(EXECUTOR);
                                 return null;
                             }
                         }));
             }
         }
         // 省略不相干代码
     }
```

## 十一、Executors快捷创建线程池的潜在问题

在很多公司（如阿里、华为等）的编程规范中，非常明确地禁止使用Executors快捷创建线程池，为什么呢？这里从源码讲起，介绍使用Executors工厂方法快捷创建线程池将会面临的潜在问题。

虽然Executors工厂类提供了构造线程池的便捷方法，但是对于服务器程序而言，大家应该杜绝使用这些便捷方法，而是直接使用线程池ThreadPoolExecutor的构造器，从而有效避免由于使用无界队列可能导致的内存资源耗尽，或者由于对线程个数不做限制而导致的CPU资源耗尽等问题。

**所以，大厂的编程规范都不允许使用Executors创建线程池，而是要求使用标准构造器ThreadPoolExecutor创建线程池。**

### 1、使用Executors创建“固定数量的线程池”的潜在问题

使用Executors创建“固定数量的线程池”的潜在问题主要存在于其workQueue上，其值为LinkedBlockingQueue（无界阻塞队列）。

如果任务提交速度持续大于任务处理速度，就会造成队列中大量的任务等待。

如果队列很大，很有可能导致JVM出现**OOM（Out Of Memory）异常**，即**内存资源耗尽**。

### 2、使用Executors创建“单线程化线程池”的潜在问题

使用Executors创建的“单线程化线程池”与“固定大小的线程池”一样，其潜在问题仍然存在于其workQueue属性上，该属性的值为LinkedBlockingQueue（无界阻塞队列）。

如果任务提交速度持续大于任务处理速度，就会造成队列大量阻塞。

如果队列很大，很有可能导致JVM的OOM异常，甚至造成内存资源耗尽。

### 3、使用Executors创建“可缓存线程池”的潜在问题

使用Executors创建的“可缓存线程池”的潜在问题存在于其最大线程数量不设限上。

由于其maximumPoolSize的值为Integer.MAX_VALUE（非常大），可以认为可以无限创建线程，如果任务提交较多，就会造成大量的线程被启动，很有可能造成**OOM异常**，甚至导致**CPU线程资源耗尽**。

### 4、使用Executors创建“可调度线程池”的潜在问题

使用Executors创建的“可缓存线程池”的潜在问题存在于其最大线程数量不设限上。由于其线程数量不设限，如果到期任务太多，就会导致**CPU的线程资源耗尽**。

