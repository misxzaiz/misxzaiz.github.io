# Java线程池

参考资料：[《Java高并发核心编程（卷2）》](https://weread.qq.com/web/bookDetail/9b93254072456ac19b9a176)

[TOC]

## 一、基本概念

### 1、创建线程的成本：

> Java线程的创建非常昂贵，需要JVM和OS（操作系统）配合完成大量的工作：
>
> （1）内存：必须为线程堆栈分配和初始化大量内存块，其中包括至少1MB的栈内存；
>
> （2）系统：需要进行系统调用，以便在OS（操作系统）中创建和注册本地线程。

### 2、使用线程池的好处

> Java高并发应用频繁创建和销毁线程的操作是非常低效的，而且是不被编程规范所允许的。
>
> 线程池主要解决以下两个问题：
>
> （1）提高性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。
>
> （2）线程管理：每个Java线程池会保持一些基本的线程统计信息，如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步人物为进行高效调度。

## 二、JUC的线程池架构

> **JUC**就是java.util.concurrent工具包的简称，该工具包是从JDK 1.5开始加入JDK的，是用于完成**高并发**、**处理多线程**的一个工具包。
>
> 在多线程编程中，任务都是一些抽象且离散的工作单元，而线程是使任务异步执行的基本机制，为了简化这些复杂的**线程管理模式**，我们使用**线程池**来统一管理线程及任务分配。

| 类/接口                          | 说明 |
| -------------------------------- | ---- |
| Executor（接口）                 |      |
| ExecutorService（接口）          |      |
| Executors                        |      |
| AbstractExecutorService          |      |
| ThreadPoolExecutor               |      |
| ScheduledExecutorService（接口） |      |
| ScheduledThreadPoolExecutor      |      |

图 JUC中线程池的类与接口的架构

![img](assets/epub_38103745_16)

### 1、Executor（接口）

> Executor是Java异步目标任务的“执行者”接口，其目标是**执行目标任务**。
>
> “执行者”Executor提供了execute()接口来**执行已提交的Runnable执行目标实例**。
>
> Executor作为执行者的角色，其目的是**提供一种将“任务提交者”与“任务执行者”分离开来的机制**。
>
> 它只包含一个**函数式方法**：

```java
void execute(Runnable command)
```



### 2、ExecutorService（接口）

> ExecutorService继承于Executor。
>
> 它是Java异步目标任务的“执行者服务接”口，**对外提供异步任务的接收服务**。
>
> ExecutorService提供了“**接收异步任务并转交给执行者**”的方法，如submit系列方法、invoke系列方法等，具体如下：

```java
// 向线程池提交单个异步任务
<T> Future<T> submit(Callable<T> task)
// 向线程池提交批量异步任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
```



### 3、AbstractExecutorService

> AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。AbstractExecutorService存在的目的是为ExecutorService中的接口**提供默认实现**。



### 4、 ThreadPoolExecutor

> ThreadPoolExecutor就是大名鼎鼎的“线程池”实现类，它继承于AbstractExecutorService抽象类。
>
> ThreadPoolExecutor是JUC线程池的核心实现类。
>
> 线程的创建和终止需要很大的开销，线程池中预先提供了指定数量的可重用线程，所以使用线程池会节省系统资源，并且每个线程池都维护了一些基础的数据统计，方便线程的管理和监控。



### 5、ScheduledExecutorService（接口）

> ScheduledExecutorService是一个接口，它继承于ExecutorService。它是一个可以完成“**延时**”和“**周期性**”任务的调度线程池接口，其功能和Timer/TimerTask类似。



### 6、ScheduledThreadPoolExecutor

> ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，它提供了ScheduledExecutorService线程池接口中“延时执行”和“周期执行”等抽象调度方法的具体实现。
>
> ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。



### 7、Executors

> Executors是一个**静态工厂类**，它通过静态工厂方法返回ExecutorService、ScheduledExecutorService等线程池示例对象，这些静态工厂方法可以理解为一些快捷的创建线程池的方法。



### 8、Timer（补充）

> 每个1秒输出一次

```java
    private static void extracted() {
        Timer timer = new Timer();
        TimerTask task = new TimerTask() {
            int count = 0;

            @Override
            public void run() {
                count++;
                System.out.println("输出信息 - 第 " + count + " 次");
            }
        };

        timer.scheduleAtFixedRate(task, 0, 1000);
    }
```

## 三、Executors的四种快捷创建线程的方法

> Java通过Executors工厂类提供4种快捷创建线程池的方法：

| 方法                             | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| newSingleThreadExecutor()        | 创建只有一个线程的线程池                                     |
| newFixedThreadPool(int nThreads) | 创建固定大小的线程池                                         |
| newCachedThreadPool()            | 创建一个不限制线程数量的线程池，任何提交的任务都将立即执行，但是空闲线程会得到及时回收 |
| newScheduledThreadPool()         | 创建一个可定期或延时执行任务的线程池                         |

### 1、newSingleThreadExecutor创建“单线程化线程池”

> 该方法用于创建一个“单线程化线程池”，也就是只有一个线程的线程池，所创建的线程池用唯一的工作线程来执行任务，使用此方法创建的线程池能**保证所有任务按照指定顺序（如FIFO）执行**。

```java
package org.example.demo.executor;

import java.util.concurrent.*;

public class newSingleThreadExecutor {

    static class RunnableTask implements Runnable {

        @Override
        public void run() {
            System.out.println("【Runnable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    static class CallableTask implements Callable {

        @Override
        public String call() throws Exception {
            System.out.println("【Callable】" + Thread.currentThread().getName() + "正在执行中！");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "【Callable】" + Thread.currentThread().getName() + "执行以完成！";
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService pool = Executors.newSingleThreadExecutor();
		// 通过execute执行Runnable
        pool.execute(new RunnableTask());
		// 通过submit提交Runnable
        pool.submit(new CallableTask()); // 一般不用
        // 通过submit提交Callable
        Future ft = pool.submit(new CallableTask());
        Thread.sleep(10);
        System.out.println(ft.get()); // 获取返回结果

        // 关闭线程池
        pool.shutdown();
    }
}
```

```java
【Runnable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1正在执行中！
【Callable】pool-1-thread-1执行以完成！
```



### 2、execute 和 submit

`pool.execute(new TargetTask())`和`pool.submit(new TargetTask())`都是用于向线程池提交任务的方法，但它们在某些方面有所区别。

1. **返回值**：`execute()`方法没有返回值，而`submit()`方法返回一个`Future`对象，可以通过该对象获取任务的执行结果或取消任务。
2. **异常处理**：当任务执行过程中出现异常时，`execute()`方法无法捕获异常，而`submit()`方法可以通过`Future`对象的`get()`方法捕获并处理异常。
3. **任务类型**：`execute()`方法接受`Runnable`类型的任务，而`submit()`方法既可以接受`Runnable`类型的任务，也可以接受`Callable`类型的任务。`Runnable`是一个无返回结果的任务，而`Callable`是一个具有返回结果的任务。
4. **执行结果**：`execute()`方法无法获取任务的执行结果，因为它没有返回值，而`submit()`方法可以通过`Future`对象的`get()`方法获取任务的执行结果。

综上所述，如果你只关心任务的执行，而不需要获取返回结果或处理异常，可以选择使用`execute()`方法。如果你需要获取任务的执行结果或处理异常，或者想提交一个带返回值的任务，可以选择使用`submit()`方法。

### 3、
