## 1、优惠卷

1. 用户发起请求抢购优惠卷请求（携带优惠卷id）；
2. 通过优惠卷查询 Redis 数据库（优惠卷信息实在添加优惠卷到MySQL时添加到 Redis 的）；
3. 检查是否在抢卷时间，如果不在抢卷时间，返回错误信息；
4. 执行 lua 脚本检查优惠卷库存是否充足及用户是否已经下单；如果库存不足或用户已经下单，则返回错误信息；否则就扣减优惠卷库存，并将用户 id 保存到 redis 的订单列表中。（保证原子性，解决超卖问题，及一人一单问题）
5. 使用 redis 生成全局唯一 id 作为优惠卷订单号，以优惠卷订单号、优惠卷id、用户id创建优惠卷订单对象，将其添加到阻塞队列中；
6. 使用异步阻塞队列处理 mysql 优惠卷订单信息，提高优惠卷抢购的高并发能力，包括扣减优惠卷库存，添加优惠卷订单。

## 2、Redis 登录

1. 用户发起获取验证码请求（携带手机号）
2. 检查手机号是否合法，如果合法就生成随机验证码，以手机号为 key，验证码为 value 将验证码保存到 redis 中，并使用阿里云服务发送验证码；
3. 用户输出验证码，发起登录请求（携带手机号及验证码）
4. 根据手机号查询 redis 获取验证码；
5. 如果验证码正确就检查用户信息是否存在（不存在就是未注册）
6. 如果用户不存在就基于该手机号创建一个用户；
7. 使用 UUID 生成随机 token 并获取请求 ip，将用户信息和请求 ip 以 token 为 key 保存到 redis 中。

## 3、登录校验

1. 用户发起请求
2. 检查是否携带token
3. 检查token是否存在
4. 检查请求ip是否符合

## 4、jdk1.7和1.8中hashmap的区别

在JDK 1.7和1.8中，HashMap的实现方式有所不同，下面是它们之间的几个主要区别：

1. 数据结构：
   - JDK 1.7中的HashMap使用数组+链表的方式来解决哈希冲突。每个桶（bucket）是一个链表，相同哈希值的键值对会存储在同一个桶中。
   - JDK 1.8中的HashMap在JDK 1.7的基础上引入了红黑树。当一个桶中的链表长度达到一定阈值（默认为8）时，链表会转换为红黑树，以提高查找的效率。

2. 并发性能：
   - JDK 1.7中的HashMap在多线程环境下存在并发安全问题，需要通过外部手段（如ConcurrentHashMap）保证线程安全。
   - JDK 1.8中的HashMap通过引入“锁分段”（lock striping）机制来提高并发性能。将桶数组分成多个段，每个段都有自己的锁，不同段之间可以并发访问，从而减少了锁竞争的范围。

3. 遍历性能：
   - JDK 1.7中的HashMap在遍历时，由于链表的无序性，性能较低，时间复杂度为O(n)。
   - JDK 1.8中的HashMap在遍历时，如果桶中的元素个数超过一定阈值（默认为8），会使用红黑树替代链表，从而提高了遍历的效率，时间复杂度为O(logn)。

4. 扩容机制：
   - JDK 1.7中的HashMap在扩容时会将所有的键值对重新计算哈希值和位置，如果哈希冲突较多，会导致性能下降。
   - JDK 1.8中的HashMap在扩容时引入了“红黑树化”的概念，只有当链表长度超过一定阈值（默认为8）时，才会进行树化操作，减少了不必要的重新计算。

综上所述，JDK 1.8中的HashMap在处理哈希冲突、并发性能、遍历性能和扩容机制等方面进行了优化，相较于JDK 1.7版本更加高效和安全。在使用HashMap时，建议尽可能使用JDK 1.8及以上的版本以获得更好的性能和功能。

## 5、锁机制

锁机制用于多线程环境下对共享资源进行访问控制，以保证数据的一致性和线程安全。以下是常见的锁机制：

1. 互斥锁（Mutex Lock）：
   - 互斥锁也称为独占锁，它提供了一种排他机制，同一时间只允许一个线程获取锁并执行临界区代码。
   - 当一个线程获取到互斥锁后，其他线程若想获取该锁则需要等待，直到持有锁的线程释放锁为止。

2. 读写锁（Read-Write Lock）：
   - 读写锁用于解决读操作与写操作之间的竞争问题。
   - 读操作之间不会相互影响，所以允许多个线程同时获取读锁并执行读操作。
   - 写操作需要独占资源，所以写操作会阻塞其他线程的读操作和写操作，只有当没有线程持有读锁或写锁时才能获取写锁。

3. 自旋锁（Spin Lock）：
   - 自旋锁是一种忙等待的锁机制，线程在发现自旋锁已经被其他线程占用时，不会进入休眠状态而是一直循环检测是否能够获取锁。
   - 自旋锁适用于锁占用时间短、线程数较少的情况，避免了线程切换带来的开销。

4. 信号量（Semaphore）：
   - 信号量是一种经典的同步机制，它可以控制多个线程同时访问某个资源。
   - 在信号量中，首先设置一个计数器，线程尝试获取信号量来执行代码，每获取一次计数器减1，当计数器为0时，其他线程需要等待。
   - 当线程使用完共享资源后，需要释放信号量，使得计数器加1，表明共享资源可供其他线程使用。

这些锁机制提供了不同的同步和并发控制方式，开发者可以根据具体的需求选择合适的锁机制来实现线程安全和共享资源的访问控制。在使用锁机制时，要注意避免死锁（Deadlock）和竞态条件（Race Condition）等多线程编程中常见的问题。

