# 文件

参考资料：[Java编程的逻辑-马俊昌-微信读书 (qq.com)](https://weread.qq.com/web/reader/b51320f05e159eb51b29226kad63251024aad61ab143c7e)

[TOC]

## 一、文件概述

### 1、基本概念

#### （1）二进制思维

1. **二进制思维**：所有文件（可执行文件、图片文件、视频文件、Word文件、压缩文件、txt文件）都是以0和1的二进制形式保存的。我们看到的图片、视频、文本，都是这些应用程序对这些二进制的解析结果。

#### （2）文件类型

1. **文件类型**：文件类型通常以拓展名的形式体现（如pdf、jpg、zip等），每种文件类型都有一定的格式，代表着文件含义和二进制之间的映射关系。
2. **文本文件**：基本上，文本文件（如txt、java、html等）里的每个二进制字节都是某个可打印字符的一部分，都可以用最基本的文本编辑器进行查看和编辑。
3. **二进制文件**：二进制文件（如zip、pdf、mp3、xlsx等）中，每个字节就不一定表示字符，可能表示颜色、字体、声音大小等，如果用基本的文本编辑器打开，异步都是满屏的乱码，需要专门的应用程序进行查看和编辑。

#### （3）文本文件的编码

1. **文本文件的编码**：文本文件中包含的基本都是可打印字符，但字符到二进制的映射（即编码）却有多种方式，如GB18030、UTF-8。
2. **BOM头**：有一种方式，可以标记该文件是UTF-8编码的，那就是在文件最开头加入三个特殊字节（0xEF 0xBB 0xBF），这三个特殊字节被称为BOM头，BOM是Byte Order Mark（即字节序标记）的缩写。需要注意的是，不是所有应用程序都支持带BOM头的UTF-8编码文件，比如PHP就不支持BOM，如果PHP源代码文件带BOM头，PHP运行就会出错。
3. **文本文件的换行符**：在Windows系统中，换行符一般是两个字符"\r\n"，即ASCII码的13（'\r'）和10（'\n'），在Linux系统中，换行符一般是一个字符"\n"。

#### （4）文件系统

1. **文件系统**：文件一般是放在硬盘上的，一个机器上可能有多个硬盘，但各种操作系统都会隐藏物理硬盘概念，提供一个逻辑上的统一结构。在Windows中，可以有多个逻辑盘，如C、D、E等，每个盘可以被格式化为一种不同的文件系统，**常见的文件系统有FAT32和NTFS**。在Linux中，只有一个逻辑的根目录，用斜线/表示。**Linux支持多种不同的文件系统，如Ext2/Ext3/Ext4等**。不同的文件系统有不同的文件组织方式、结构和特点，不过，一般编程时，语言和类库为我们提供了统一的API，我们并不需要关心其细节。
2. **文件路径**：路径有两种形式：一种是绝对路径，另一种是相对路径。
3. **路径分隔符**：在Windows中，目录之间用反斜线分隔，如C:\code\hello.java，在Linux中，目录之间用斜线分隔，如/Users/laoma/Desktop/code/hello.java。在Java中，java.io.File类定义了一个**静态变量File.separator**，表示路径分隔符，编程时应使用该变量而避免硬编码。
4. **文件的元数据信息**：如文件名、创建时间、修改时间、文件大小等。文件还有一个是否隐藏的性质。在Linux系统中，如果文件名以．开头，则为隐藏文件；在Windows系统中，隐藏是文件的一个属性，可以进行设置。
5. **访问权限**：大部分文件系统的文件和目录具有访问权限的概念，对所有者、用户组可以有不同的权限，具体权限包括**读、写、执行**。
6. **文件名**：文件名有大小写是否敏感的概念。在Windows系统中，一般是大小写不敏感的，而Linux则一般是大小写敏感的。也就是说，同一个目录下，abc.txt和ABC.txt在Windows中被视为同一个文件，而在Linux中则被视为不同的文件。
7. **临时文件**：操作系统中有一个临时文件的概念。临时文件位于一个特定目录，比如Windows 7中，临时文件一般位于“C:\Users\用户名\AppData\Local\Temp”; Linux系统中，临时文件位于/tmp。操作系统会有一定的策略自动清理不用的临时文件。临时文件一般不是用户手工创建的，而是应用程序产生的，用于临时目的。

#### （5）文件读写

1. **文件读写**：文件是放在硬盘上的，程序处理文件需要将文件读入内存，修改后，需要写回硬盘。操作系统提供了对文件读写的基本API，不同操作系统的接口和实现是不一样的，不过，有一些共同的概念。Java封装了操作系统的功能，提供了统一的API。
2. **硬盘的访问延时**：硬盘的访问延时，相比内存，是很慢的。操作系统和硬盘一般是按块批量传输，而不是按字节，以摊销延时开销，块大小一般至少为512字节，即使应用程序只需要文件的一个字节，操作系统也会至少将一个块读进来。一般而言，应尽量减少接触硬盘，接触一次，就一次多做一些事情。对于网络请求和其他输入输出设备，原则都是类似的。
3. **一般读写文件需要两次数据复制**：比如读文件，需要先从硬盘复制到操作系统内核，再从内核复制到应用程序分配的内存中。操作系统运行所在的环境和应用程序是不一样的，操作系统所在的环境是内核态，应用程序是用户态，应用程序调用操作系统的功能，需要两次环境的切换，先从用户态切到内核态，再从内核态切到用户态。这种用户态/内核态的切换是有开销的，应尽量减少这种切换。
4. **缓冲区**：为了提升文件操作的效率，应用程序经常使用一种常见的策略，即使用缓冲区。读文件时，即使目前只需要少量内容，但预知还会接着读取，就一次读取比较多的内容，放到读缓冲区，下次读取时，如果缓冲区有，就直接从缓冲区读，减少访问操作系统和硬盘。写文件时，先写到写缓冲区，写缓冲区满了之后，再一次性调用操作系统写到硬盘。不过，需要注意的是，在写结束的时候，要记住将缓冲区的剩余内容同步到硬盘。操作系统自身也会使用缓冲区，不过，应用程序更了解读写模式，恰当使用往往可以有更高的效率。
5. **文件描述符**：操作系统操作文件一般有打开和关闭的概念。打开文件会在操作系统内核建立一个有关该文件的内存结构，这个结构一般通过一个整数索引来引用，这个索引一般称为文件描述符。这个结构是消耗内存的，操作系统能同时打开的文件一般也是有限的，在不用文件的时候，应该记住关闭文件。关闭文件一般会同步缓冲区内容到硬盘，并释放占据的内存结构。
6. **内存映射文件**：操作系统一般支持一种称为内存映射文件的高效的随机读写大文件的方法，将文件直接映射到内存，操作内存就是操作文件。在内存映射文件中，只有访问到的数据才会被实际复制到内存，且数据只会复制一次，被操作系统以及多个应用程序共享。

### 2、Java文件

在Java处理文件有一些基本概念和类，包括流、装饰器设计模式、Reader/Writer、随机读写文件、FIle、NIO、序列化和反序列化。

#### （1）流

在Java中，文件一般不单独处理，而是视为输入输出（Input/Ouput， **IO**）设备中的一种。Java使用基本统一的概念处理所有IO，包括键盘、显示终端、网络等。

这个统一的概念是流，流有**输入流**和**输出流**之分，输入流就是可以从中获取数据，输入流的实际提供者可以是键盘、文件、网络等；输出流就是可以向其中写入数据，输出流的实际目的地可以是显示终端、文件、网络等。

Java IO的基本类大多位于包**java.io**中。类**InputStream**表示输入流，**OutputStream**表示输出流，而FileInputStream表示文件输入流，FileOutputStream表示文件输出流。

有了流的概念，就有了很多面向流的代码，比如对流进行加密、压缩、计算信息摘要、计算检验和等，这些代码接受的参数和返回结果都是抽象的流，它们构成了一个协作体系，这类似于之前介绍的接口概念、面向接口的编程，以及容器类协作体系。一些实际上不是IO的数据源和目的地也转换为了流，以方便参与这种协作，比如字节数组，也包装为了流ByteArrayInputStream和ByteArrayOutputStream。

#### （2）装饰器设计模式

基本的流按字节读写，没有缓冲区，这不方便使用。Java解决这个问题的方法是使用装饰器设计模式，**引入了很多装饰类，对基本的流增加功能**，以方便使用。一般一个类只关注一个方面，实际使用时，经常会需要多个装饰类。

Java中有很多装饰类，有两个基类：**过滤器输入流FilterInputStream**和**过滤器输出流FilterOutputStream**。过滤类似于自来水管道，流入的是水，流出的也是水，功能不变，或者只是增加功能。它有很多子类，这里列举一些：

1）对流起缓冲装饰的子类是BufferedInputStream和BufferedOutputStream。

2）可以按8种基本类型和字符串对流进行读写的子类是DataInputStream和DataOutput-Stream。

3）可以对流进行压缩和解压缩的子类有GZIPInputStream、ZipInputStream、GZIPOutput-Stream和ZipOutputStream。

4）可以将基本类型、对象输出为其字符串表示的子类有PrintStream。

众多的装饰类使得整个类结构变得比较复杂，完成基本的操作也需要比较多的代码；其优点是非常灵活，在解决某些问题时也很优雅。

#### （3）Reader/Writer

以InputStream/OutputStream为基类的流基本都是以二进制形式处理数据的，不能够方便地**处理文本文件**，没有编码的概念，能够方便地按字符处理文本数据的基类是Reader和Writer，它也有很多子类：

1）读写文件的子类是FileReader和FileWriter。

2）起缓冲装饰的子类是BufferedReader和BufferedWriter。

3）将字符数组包装为Reader/Writer的子类是CharArrayReader和CharArrayWriter。

4）将字符串包装为Reader/Writer的子类是StringReader和StringWriter。

5）将InputStream/OutputStream转换为Reader/Writer的子类是InputStreamReader和OutputStreamWriter。

6）将基本类型、对象输出为其字符串表示的子类是PrintWriter。

#### （4）随机读写文件

大部分情况下，使用流或Reader/Writer读写文件内容，但Java提供了一个独立的可以随机读写文件的类RandomAccessFile，适用于大小已知的记录组成的文件。该类在日常应用开发中用得比较少，但在一些系统程序中用得比较多。

#### （5）File

以上介绍的类基本都位于包java.io下，Java还有一个关于IO操作的包java.nio, nio表示New IO，这个包下同样包含大量的类。

NIO代表一种不同的看待IO的方式，它有缓冲区和通道的概念。利用缓冲区和通道往往可以达成和流类似的目的，不过，它们更接近操作系统的概念，某些操作的性能也更高。比如，复制文件到网络，通道可以利用操作系统和硬件提供的DMA机制（Direct Memory Access，直接内存存取），不用CPU和应用程序参与，直接将数据从硬盘复制到网卡。

除了看待方式不同，NIO还支持一些比较底层的功能，如内存映射文件、文件加锁、自定义文件系统、非阻塞式IO、异步IO等。

不过，这些功能要么是比较底层，普通应用程序用到得比较少，要么主要适用于网络IO操作，我们大多不会介绍，只会介绍内存映射文件。

#### （6）序列化和反序列化

简单来说，序列化就是将内存中的Java对象持久保存到一个流中，反序列化就是从流中恢复Java对象到内存。**序列化和反序列化主要有两个用处：一是对象状态持久化，二是网络远程调用，用于传递和返回对象。**

Java主要通过接口**Serializable**和**类ObjectInputStream/ObjectOutputStream**提供对序列化的支持，基本的使用是比较简单的，但也有一些复杂的地方。不过，Java的默认序列化有一些缺点，比如，序列化后的形式比较大、浪费空间，序列化/反序列化的性能也比较低，更重要的问题是，它是Java特有的技术，不能与其他语言交互。

ⅩML是前几年最为流行的描述结构性数据的语言和格式，Java对象也可以序列化为ⅩML格式。ⅩML容易阅读和编辑，且可以方便地与其他语言进行交互。ⅩML强调格式化但比较“笨重”, JSON是近几年来逐渐流行的轻量级的数据交换格式，在很多场合替代了ⅩML，也非常容易阅读和编辑。Java对象也可以序列化为JSON格式，且与其他语言进行交互。

ⅩML和JSON都是文本格式，人容易阅读，但占用的空间相对大一些，在只用于网络远程调用的情况下，有很多流行的、跨语言的、精简且高效的对象序列化机制，如ProtoBuf、Thrift、MessagePack等。其中，MessagePack是二进制形式的JSON，更小更快。

## 二、二进制文件和字节流

以二进制读写的主要流：

| 流                                         | 说明                                         |
| ------------------------------------------ | -------------------------------------------- |
| InputStream/OutputStream                   | 基类，抽像类                                 |
| FileInputStream/FileOutputStream           | 输入源和输出目标是文件的流                   |
| ByteArrayInputStream/ByteArrayOutputStream | 输入源和输出目标是字节数组的流               |
| DataInputStream/DataOutputStream           | 装饰类，按基本类型和字符串而非只是字节读写流 |
| BufferedInputStream/BufferedOutputStream   | 装饰类，对输入输出流提供缓冲功能             |

### 1、InputStream/OutputStream

#### （1）InputStream

1. public abstract int **read()** throws IOException：
   - read方法从流中读取下一个字节，返回类型为int，但取值为0～255，当读到流结尾的时候，返回值为-1，如果流中没有数据，read方法会阻塞直到数据到来、流关闭或异常出现。
   - 异常出现时，read方法抛出异常，类型为IOException，这是一个受检异常，调用者必须进行处理。
   - read是一个抽象方法，具体子类必须实现，FileInputStream会调用本地方法。所谓本地方法，一般不是用Java写的，大多使用C语言实现，具体实现往往与虚拟机和操作系统有关。
2. public int **read(byte b[])** throws IOException
   - 可以一次读取多个字节
   - 读入的字节放入参数数组b中，第一个字节存入b[0]，第二个存入b[1]，以此类推，一次最多读入的字节个数为数组b的长度，但实际读入的个数可能小于数组长度，返回值为实际读入的字节个数。
   - 如果刚开始读取时已到流结尾，则返回-1；否则，只要数组长度大于0，该方法都会尽力至少读取一个字节，如果流中一个字节都没有，它会阻塞，异常出现时也是抛出IOException。
   - 该方法不是抽象方法，InputStream有一个默认实现，主要就是循环调用读一个字节的read方法，但子类如FileInputStream往往会提供更为高效的实现。
3. public int **read(byte b[], int off, int len)** throws IOException
   - 批量读取还有一个更为通用的重载方法
   - 读入的第一个字节放入b[off]，最多读取len个字节，read(byte b[])就是调用了该方法
4. public void **close()** throws IOException
   - 流读取结束后，应该关闭，以释放相关资源
   - 不管read方法是否抛出了异常，都应该调用close方法，所以close方法通常应该放在finally语句内。close方法自己可能也会抛出IOException，但通常可以捕获并忽略。
5. public long **skip(long n)** throws IOException
   - skip跳过输入流中n个字节，因为输入流中剩余的字节个数可能不到n，所以返回值为实际略过的字节个数。InputStream的默认实现就是尽力读取n个字节并扔掉，子类往往会提供更为高效的实现，FileInputStream会调用本地方法。在处理数据时，对于不感兴趣的部分，skip往往比读取然后扔掉的效率要高。
6. public int **available()** throws IOException
   - available返回下一次不需要阻塞就能读取到的大概字节个数。InputStream的默认实现是返回0，子类会根据具体情况返回适当的值，FileInputStream会调用本地方法。在文件读写中，这个方法一般没什么用，但在从网络读取数据时，可以根据该方法的返回值在网络有足够数据时才读，以避免阻塞。
7. public synchronized void **mark(int readlimit)**
   - 一般的流读取都是一次性的，且只能往前读，不能往后读，但有时可能希望能够先看一下后面的内容，根据情况再重新读取。比如，处理一个未知的二进制文件，我们不确定它的类型，但可能可以通过流的前几十个字节判断出来，判读出来后，再重置到流开头，交给相应类型的代码进行处理。
   - InputStream定义了三个方法：mark、reset、markSupported，用于支持从读过的流中重复读取。怎么重复读取呢？先使用mark()方法将当前位置标记下来，在读取了一些字节，希望重新从标记位置读时，调用reset方法。能够重复读取不代表能够回到任意的标记位置，mark方法有一个参数readLimit，表示在设置了标记后，能够继续往后读的最多字节数，如果超过了，标记会无效。为什么会这样呢？因为之所以能够重读，是因为流能够将从标记位置开始的字节保存起来，而保存消耗的内存不能无限大，流只保证不会小于readLimit。
   - 不是所有流都支持mark、reset方法，是否支持可以通过markSupported的返回值进行判断。InpuStream的默认实现是不支持，FileInputStream也不直接支持，但BufferedInput-Stream和ByteArrayInputStream可以支持。
8. public boolean **markSupported()**
9. public synchronized void **reset()** throws IOException

#### （2）OutputStream

1. public abstract void **write(int b)** throws IOException;
   - 向流中写入一个字节，参数类型虽然是int，但其实只会用到最低的8位。这个方法是抽象方法，具体子类必须实现，FileInputStream会调用本地方法。
2. public void **write(byte b[])** throws IOException
3. public void **write(byte b[], int off, int len)** throws IOException
   - 在第二个方法中，第一个写入的字节是b[off]，写入个数为len，最后一个是b[off+len-1]，第一个方法等同于调用write(b, 0, b.length); 。OutputStream的默认实现是循环调用单字节的write()方法，子类往往有更为高效的实现，FileOutpuStream会调用对应的批量写本地方法。
4. public void **flush()** throws IOException
   - flush方法将缓冲而未实际写的数据进行实际写入，比如，在BufferedOutputStream中，调用flush方法会将其缓冲区的内容写到其装饰的流中，并调用该流的flush方法。基类OutputStream没有缓冲，flush方法代码为空。
   - 需要说明的是文件输出流FileOutputStream，你可能会认为，调用flush方法会强制确保数据保存到硬盘上，但实际上不是这样，FileOutputStream没有缓冲，没有重写flush方法，调用flush方法没有任何效果，数据只是传递给了操作系统，但操作系统什么时候保存到硬盘上，这是不一定的。要确保数据保存到了硬盘上，可以调用FileOutputStream中的特有方法，具体待会介绍。
5. public void **close()** throws IOException
   - close方法一般会首先调用flush方法，然后再释放流占用的系统资源。同InputStream一样，close方法一般应该放在finally语句内。

### 2、FileInputStream/FileOutputStream

FileInputStream和FileOutputStream的输入源和输出目标是文件

#### （1）FileOutputStream

FileOutputStream有多个构造方法，其中两个如下所示：

```java
public FileOutputStream(File file, boolean append) throws FileNotFoundException
public FileOutputStream(String name) throws FileNotFoundException
```

File类型的参数file和字符串的类型的参数name都表示文件路径，路径可以是绝对路径，也可以是相对路径，如果文件已存在，append参数指定是追加还是覆盖，true表示追加， false表示覆盖，第二个构造方法没有append参数，表示覆盖。

new一个FileOutputStream对象会实际打开文件，操作系统会分配相关资源。如果当前用户没有写权限，会抛出异常SecurityException，它是一种RuntimeException。

如果指定的文件是一个已存在的目录，或者由于其他原因不能打开文件，会抛出异常FileNotFoundException，它是IOException的一个子类。

我们看一段简单的代码，将字符串"hello, 123，老马"写到文件hello.txt中：

```java
import java.io.*;
import java.nio.charset.Charset;

public class IOStream {
    private static void fileOutputStream() throws IOException {
        OutputStream fos = new FileOutputStream("D:" + File.separator + "hello.txt",true);
        try {
            String data = "hello, 123, 老马";
            byte[] bytes = data.getBytes(Charset.forName("UTF-8"));
            fos.write(bytes);
        } finally {
            fos.close();
        }
    }
}
```

OutputStream只能以byte或byte数组写文件，为了写字符串，我们调用String的get-Bytes方法得到它的UTF-8编码的字节数组，再调用write()方法，写的过程放在try语句内，在finally语句中调用close方法。

FileOutputStream还有两个额外的方法：

```java
public FileChannel getChannel()
public final FileDescriptor getFD()
```

FileChannel定义在java.nio中，表示文件通道概念。我们不会深入介绍通道，但内存映射文件方法定义在FileChannel中，我们会在下章介绍。FileDescriptor表示文件描述符，它与操作系统的一些文件内存结构相连，在大部分情况下，我们不会用到它，不过它有一个方法sync：

```java
public native void sync() throws SyncFailedException;
```

这是一个本地方法，它会确保将操作系统缓冲的数据写到硬盘上。注意与Output-Stream的flush方法相区别，flush方法只能将应用程序缓冲的数据写到操作系统，sync方法则确保数据写到硬盘，不过一般情况下，我们并不需要手工调用它，只要操作系统和硬件设备没问题，数据迟早会写入。在一定特定情况下，一定需要确保数据写入硬盘，则可以调用该方法。

#### （2）FileInputStream

FileInputStream的主要构造方法有：

```java
public FileInputStream(String name) throws FileNotFoundException
public FileInputStream(File file) throws FileNotFoundException
```

参数与FileOutputStream类似，可以是文件路径或File对象，但**必须是一个已存在的文件**，不能是目录。new一个FileInputStream对象也会实际打开文件，操作系统会分配相关资源，如果文件不存在，会抛出异常FileNotFoundException，**如果当前用户没有读的权限，会抛出异常SecurityException**。我们看一段简单的代码，将上面写入的文件"hello.txt"读到内存并输出：

```java
import java.io.*;
import java.nio.charset.Charset;

public class IOStream {
    private static void fileInputStream() throws IOException {
        InputStream fis = new FileInputStream("D:" + File.separator + "hello.txt");
        try {
            byte[] buf = new byte[1024];
            int off = 0;
            int bytesRead = 0;
            while ((bytesRead = fis.read(buf, off, 1024 - off)) != -1){
                off += bytesRead;
            }
            String s = new String(buf, 0, off, "UTF-8");
            System.out.println(s);
        } finally {
            fis.close();
        }
    }
}
```

不过，**这还是假定文件内容长度不超过一个固定的大小1024**。如果不确定文件内容的长度，但不希望一次性分配过大的byte数组，又希望将文件内容全部读入，怎么做呢？可以借助ByteArrayOutputStream，我们下面进行介绍。

### 3、ByteArrayInputStream/ByteArrayOutputStream

它们的输入源和输出目标是字节数组。

#### （1）ByteArrayOutputStream

ByteArrayOutputStream的输出目标是一个byte数组，这个数组的长度是根据数据内容动态扩展的，它有两个构造方法：

```java
public ByteArrayOutputStream()
public ByteArrayOutputStream(int size)
```

第二个构造方法中的size指定的就是初始的数组大小，如果没有指定，则长度为32。在调用write方法的过程中，如果数组大小不够，会进行扩展，扩展策略同样是指数扩展，每次至少增加一倍。

ByteArrayOutputStream有如下方法，可以方便地将数据转换为字节数组或字符串：

```java
public synchronized byte[] toByteArray()
public synchronized String toString()
public synchronized String toString(String charsetName)
```

toString()方法使用系统默认编码。ByteArrayOutputStream中的数据也可以方便地写到另一个OutputStream：

```java
public synchronized void writeTo(OutputStream out) throws IOException
```

ByteArrayOutputStream还有如下额外方法：

```java
public synchronized int size()
public synchronized void reset()
```

size方法返回当前写入的字节个数。reset方法重置字节个数为0, reset后，可以重用已分配的数组。使用ByteArrayOutputStream，我们可以改进前面的读文件代码，确保将所有文件内容读入：

**存在问题：其实只能读1024个**

```java
import java.io.*;
import java.nio.charset.Charset;

public class IOStream {
    private static void fileInputStream() throws IOException {
        InputStream fis = new FileInputStream("D:" + File.separator + "hello.txt");
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            byte[] buf = new byte[1024];
            int bytesRead = 0;
            if ((bytesRead = fis.read(buf))!=-1) {
                baos.write(buf, 0, bytesRead);
            }
            String data = baos.toString("UTF-8");
            System.out.println(data);
        } finally {
            baos.close();
            fis.close();
        }
    }
}	
```

读入的数据先写入ByteArrayOutputStream中，读完后，再调用其toString方法获取完整数据。

#### （2）ByteArrayInputStream

ByteArrayInputStream将byte数组包装为一个输入流，是一种适配器模式，它的构造方法有：

```java
public ByteArrayInputStream(byte buf[])
public ByteArrayInputStream(byte buf[], int offset, int length)
```

第二个构造方法以buf中offset开始的length个字节为背后的数据。ByteArrayInput-Stream的所有数据都在内存，支持mark/reset重复读取。

为什么要将byte数组转换为InputStream呢？这与容器类中要将数组、单个元素转换为容器接口的原因是类似的，有很多代码是以InputStream/OutputSteam为参数构建的，它们构成了一个协作体系，将byte数组转换为InputStream可以方便地参与这种体系，复用代码。

### 4、DataInputStream/DataOutputStream

上面介绍的类都只能以字节为单位读写，如何以其他类型读写呢？比如int、double。可以使用DataInputStream/DataOutputStream，它们都是装饰类。

#### （1）DataOutputStream

DataOutputStream是装饰类基类FilterOutputStream的子类，FilterOutputStream是Output-Stream的子类，它的构造方法是：

```java
public FilterOutputStream(OutputStream out)
```

它接受一个已有的OutputStream，基本上将所有操作都代理给了它。DataOutputStream实现了DataOutput接口，可以以各种基本类型和字符串写入数据，部分方法如下：

```java
void writeBoolean(boolean v) throws IOException;
void writeInt(int v) throws IOException;
void writeUTF(String s) throws IOException;
```





## 三、文本文件和字符流
