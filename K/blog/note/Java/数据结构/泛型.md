# 泛型

参考资料：[Java编程的逻辑-马俊昌-微信读书 (qq.com)](https://weread.qq.com/web/reader/b51320f05e159eb51b29226k34132fc02293416a75f431d)

[TOC]

## 一、基本概念

泛型将接口的概念进一步延伸，同一套代码可以用于多种数据类型，不仅可以复用代码，降低耦合，还可以提高代码的可读性和安全性。

### 1、泛型类

泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入。

#### (1) 基本实例

```java
public class Pair<U,V> {
    U first;
    V second;
    public Pair(U first, V second){
        this.first = first;
        this.second = second;
    }
    public U getFirst() {
        return first;
    }
    public V getSecond() {
        return second;
    }
    @Override
    public String toString() {
        return "Pair{" +
                "first=" + first +
                ", second=" + second +
                '}';
    }
}
```

```java
static void test(){
    Pair<Integer,String> pair = new Pair<>(1,"nihao");
    System.out.println(pair); // Pair{first=1, second=nihao}
}
```

#### (2) **内部原理**：

Java有Java编译器和Java虚拟机，编译器将Java源代码转换为．class文件，虚拟机加载并运行．class文件。

对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，就像上面的普通Pair类代码及其使用代码一样，将类型参数U擦除，替换为Object，插入必要的**强制类型转换**。Java虚拟机实际执行的时候，它是不知道泛型这回事的，只知道普通的类及代码。

Java泛型是通过**擦除**实现的，类定义中的类型参数如U会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数。

#### (3) 使用泛型的好处

- 更好的安全性
- 更好的可读性

语言和程序设计的一个重要目标是将bug尽量消灭在摇篮里，能消灭在写代码的时候，就不要等到代码写完程序运行的时候。只使用Object，代码写错的时候，开发环境和编译器不能帮我们发现问题，看代码：

```java
Pair pair = new Pair("老马",1);
Integer id = (Integer)pair.getFirst();
String name = (String)pair.getSecond();
```

看出问题了吗？写代码时不小心把类型弄错了，不过，代码编译时是没有任何问题的，但运行时程序抛出了类型转换异常ClassCastException。如果使用泛型，则不可能犯这个错误，比如下面的代码：

```java
Pair<String, Integer> pair = new Pair<>("老马",1);
Integer id = pair.getFirst(); //有编译错误
String name = pair.getSecond(); //有编译错误
```

开发环境（如Eclipse）会提示**类型错误**，即使没有好的开发环境，编译时Java编译器也会提示。这称之为**类型安全**，也就是说，通过使用泛型，开发环境和编译器能确保不会用错类型，为程序多设置一道安全防护网。使用泛型，还可以省去烦琐的强制类型转换，再加上明确的类型信息，代码可读性也会更好。

### 2、容器类

泛型类最常见的用途是作为容器类。所谓容器类，简单地说，就是容纳并管理多项数据的类。数组就是用来管理多项数据的，但数组有很多限制，比如，长度固定，插入、删除操作效率比较低。

#### （1）动态数组容器实例

```java
        public class DynamicArray<E> {
            private static final int DEFAULT_CAPACITY = 10;
            private int size;
            private Object[] elementData;
            public DynamicArray() {
                this.elementData = new Object[DEFAULT_CAPACITY];
            }
            private void ensureCapacity(int minCapacity) {
                int oldCapacity = elementData.length;
                if(oldCapacity >= minCapacity){
                    return;
                }
                int newCapacity = oldCapacity ＊ 2;
                if(newCapacity < minCapacity)
                    newCapacity = minCapacity;
                elementData = Arrays.copyOf(elementData, newCapacity);
            }
            public void add(E e) {
                ensureCapacity(size + 1);
                elementData[size++] = e;
            }
            public E get(int index) {
                return (E)elementData[index];
            }
            public int size() {
                return size;
            }
            public E set(int index, E element) {
                E oldValue = get(index);
                elementData[index] = element;
                return oldValue;
            }
        }
```

DynamicArray就是一个动态数组，内部代码与我们之前分析过的StringBuilder类似，通过ensureCapacity方法来根据需要扩展数组。作为一个容器类，它容纳的数据类型是作为参数传递过来的，比如，存放Double类型：

```java
        DynamicArray<Double> arr = new DynamicArray<Double>();
        Random rnd = new Random();
        int size = 1+rnd.nextInt(100);
        for(int i=0; i<size; i++){
            arr.add(Math.random());
        }
        Double d = arr.get(rnd.nextInt(size));
```

这就是一个简单的容器类，适用于各种数据类型，且类型安全。后文还会以Dynamic-Array为例进行扩展，以解释泛型概念。

**具体的类型还可以是一个泛型类**，比如，可以这样写：

```java
        DynamicArray<Pair<Integer, String>> arr = new DynamicArray<>()
```

arr表示一个动态数组，每个元素是Pair<Integer, String>类型。

### 3、泛型方法

除了泛型类，方法也可以是泛型的，而且，一个方法是不是泛型的，与它所在的类是不是泛型没有什么关系。我们看个例子：

```java
        public static <T> int indexOf(T[] arr, T elm){
            for(int i=0; i<arr.length; i++){
                if(arr[i].equals(elm)){
                    return i;
                }
            }
            return -1;
        }
```

这个方法就是一个泛型方法，类型参数为T，放在返回值前面，它可以如下调用：

```java
        indexOf(new Integer[]{1,3,5}, 10)
```

也可以如下调用：

```java
        indexOf(new String[]{"hello", "老马", "编程"}, "老马")
```

indexOf表示一个算法，在给定数组中寻找某个元素，这个算法的基本过程与具体数据类型没有什么关系，通过泛型，它可以方便地应用于各种数据类型，且由编译器保证类型安全。

与泛型类一样，类型参数可以有多个，以逗号分隔，比如：

```java
        public static <U, V> Pair<U, V> makePair(U first, V second){
            Pair<U, V> pair = new Pair<>(first, second);
            return pair;
        }
```

与泛型类不同，调用方法时一般并不需要特意指定类型参数的实际类型，比如调用make-Pair：

```java
        makePair(1, "老马");
```

并不需要告诉编译器U的类型是Integer, V的类型是String, Java编译器可以自动推断出来。

### 4、泛型接口

接口也可以是泛型的，我们之前介绍过的Comparable和Comparator接口都是泛型的，它们的代码如下：

```java
        public interface Comparable<T> {
            public int compareTo(T o);
        }
        public interface Comparator<T> {
            int compare(T o1, T o2);
            boolean equals(Object obj);
        }
```

与前面一样，T是类型参数。实现接口时，应该指定具体的类型，比如，对Integer类，实现代码是：

```java
        public final class Integer extends Number implements Comparable<Integer>{
            public int compareTo(Integer anotherInteger) {
                return compare(this.value, anotherInteger.value);
            }
            //其他代码
        }
```

通过implements Comparable<Integer>, Integer实现了Comparable接口，指定了实际类型参数为Integer，表示Integer只能与Integer对象进行比较。

再看Comparator的一个例子，String类内部一个Comparator的接口实现为：

```java
        private static class CaseInsensitiveComparator
                implements Comparator<String> {
            public int compare(String s1, String s2) {
                //省略主体代码
            }
        }
```

这里，指定了实际类型参数为String。

### 5、类型参数的限定

在之前的介绍中，无论是泛型类、泛型方法还是泛型接口，关于类型参数，我们都知之甚少，只能把它当作Object，但Java支持限定这个参数的一个上界，也就是说，参数必须为给定的上界类型或其子类型，这个限定是通过**extends**关键字来表示的。这个上界可以是某个具体的类或者某个具体的接口，也可以是其他的类型参数，我们逐个介绍其应用。

#### (1) 上界为某个具体值

比如，上面的Pair类，可以定义一个子类NumberPair，限定两个类型参数必须为Number，代码如下：

```java
        public class NumberPair<U extends Number, V extends Number>
              extends Pair<U, V> {
              public NumberPair(U first, V second) {
                  super(first, second);
              }
        }
```

**限定类型后，就可以使用该类型的方法了**。比如，对于NumberPair类，first和second变量就可以当作Number进行处理了。比如可以定义一个求和方法，如下所示：

```java
        public double sum(){
            return getFirst().doubleValue() +getSecond().doubleValue();
        }
```

可以这么用：

```java
        NumberPair<Integer, Double> pair = new NumberPair<>(10, 12.34);
        double sum = pair.sum();
```

限定类型后，如果类型使用错误，编译器会提示。指定边界后，类型擦除时就不会转换为Object了，而是会转换为它的边界类型，这也是容易理解的。

#### (2) 上界为某个接口

在泛型方法中，一种常见的场景是限定类型必须实现Comparable接口，我们来看代码：

```java
        public static <T extends Comparable> T max(T[] arr){
            T max = arr[0];
            for(int i=1; i<arr.length; i++){
                if(arr[i].compareTo(max)>0){
                    max = arr[i];
                }
            }
            return max;
        }
```

max方法计算一个泛型数组中的最大值。计算最大值需要进行元素之间的比较，要求元素实现Comparable接口，所以给类型参数设置了一个上边界Comparable, T必须实现Comparable接口。

不过，直接这么编写代码，Java中会给一个警告信息，因为Comparable是一个泛型接口，它也需要一个类型参数，所以完整的方法声明应该是：

```java
        public static <T extends Comparable<T>> T max(T[] arr){
            //主体代码
        }
```

<T extends Comparable<T>>是一种令人费解的语法形式，这种形式称为递归类型限制，可以这么解读：T表示一种数据类型，必须实现Comparable接口，且必须可以与相同类型的元素进行比较。

#### (3) 上界为其他类型参数

上面的限定都是指定了一个明确的类或接口，Java支持一个类型参数以另一个类型参数作为上界。为什么需要这个呢？我们看个例子，给上面的DynamicArray类增加一个实例方法addAll，这个方法将参数容器中的所有元素都添加到当前容器里来，直觉上，代码可以如下书写：

```java
        public void addAll(DynamicArray<E> c) {
            for(int i=0; i<c.size; i++){
                add(c.get(i));
            }
        }
```

但这么写有一些局限性，我们看使用它的代码：

```java
        DynamicArray<Number> numbers = new DynamicArray<>();
        DynamicArray<Integer> ints = new DynamicArray<>();
        ints.add(100);
        ints.add(34);
        numbers.addAll(ints); //会提示编译错误
```

numbers是一个Number类型的容器，ints是一个Integer类型的容器，我们希望将ints添加到numbers中，因为Integer是Number的子类，应该说，这是一个合理的需求和操作。

但Java会在numbers.addAll(ints)这行代码上提示编译错误：addAll需要的参数类型为DynamicArray<Number>，而传递过来的参数类型为DynamicArray<Integer>，不适用。Integer是Number的子类，怎么会不适用呢？

事实就是这样，确实不适用，而且是很有道理的，假设适用，我们看下会发生什么。

```java
        DynamicArray<Integer> ints = new DynamicArray<>();
        DynamicArray<Number> numbers = ints; //假设这行是合法的
        numbers.add(new Double(12.34));
```

那最后一行就是合法的，这时，DynamicArray<Integer>中就会出现Double类型的值，而这显然破坏了Java泛型关于类型安全的保证。

我们强调一下，**虽然Integer是Number的子类，但DynamicArray<Integer>并不是DynamicArray<Number>的子类，DynamicArray<Integer>的对象也不能赋值给Dynamic-Array<Number>的变量**，这一点初看上去是违反直觉的，但这是事实，必须要理解这一点。

不过，我们的需求是合理的，将Integer添加到Number容器中并没有问题。这个问题可以通过**类型限定**来解决：

```java
        public <T extends E> void addAll(DynamicArray<T> c) {
            for(int i=0; i<c.size; i++){
                add(c.get(i));
            }
        }
```

E是DynamicArray的类型参数，T是addAll的类型参数，T的上界限定为E，这样，下面的代码就没有问题了：

```java
        DynamicArray<Number> numbers = new DynamicArray<>();
        DynamicArray<Integer> ints = new DynamicArray<>();
        ints.add(100);
        ints.add(34);
        numbers.addAll(ints);
```

对于这个例子，这种写法有点烦琐，8.2节中我们会介绍一种简化的方式。

## 二、解析通配符

### 1、更简洁的参数类型限定

在上面，我们提到一个例子，为了将Integer对象添加到Number容器中，我们的类型参数使用了其他类型参数作为上界，我们提到，这种写法有点烦琐，它可以替换为更为简洁的通配符形式：

```java
        public void addAll(DynamicArray<? extends E> c) {
            for(int i=0; i<c.size; i++){
                add(c.get(i));
            }
        }
```

这个方法没有定义类型参数，c的类型是DynamicArray<? extends E>, **？表示通配符**，**<? extends E>表示有限定通配符**，匹配E或E的某个子类型，具体什么子类型是未知的。使用这个方法的代码不需要做任何改动，还可以是：

```java
        DynamicArray<Number> numbers = new DynamicArray<>();
        DynamicArray<Integer> ints = new DynamicArray<>();
        ints.add(100);
        ints.add(34);
        numbers.addAll(ints);
```

这里，E是Number类型，DynamicArray<? extends E>可以匹配DynamicArray<Integer>。

那么问题来了，同样是extends关键字，同样应用于泛型，<T extends E>和<? extends E>到底有什么关系？它们用的地方不一样，我们解释一下：

1）<T extends E>用于定义类型参数，它声明了一个类型参数T，**可放在泛型类定义中类名后面**、**泛型方法返回值前面**。

2）<? extends E>用于实例化类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。

虽然它们不一样，但两种写法经常可以达成相同目标，比如，前面例子中，下面两种写法都可以：

```java
        public void addAll(DynamicArray<? extends E> c)
        public <T extends E> void addAll(DynamicArray<T> c)
```

那么，到底应该用哪种形式呢？我们先进一步理解通配符，然后再解释。

### 2、理解通配符

**除了有限定通配符，还有一种通配符**，形如DynamicArray<? >，**称为无限定通配符**。我们来看个例子，在DynamicArray中查找指定元素，代码如下：

```java
        public static int indexOf(DynamicArray<? > arr, Object elm){
            for(int i=0; i<arr.size(); i++){
                if(arr.get(i).equals(elm)){
                    return i;
                }
            }
            return -1;
        }
```

其实，这种无限定通配符形式也可以改为使用类型参数。也就是说，下面的写法：

```java
        public static int indexOf(DynamicArray<? > arr, Object elm)
```

可以改为：

```java
        public static <T> int indexOf(DynamicArray<T> arr, Object elm)
```

不过，通配符形式更为简洁。虽然通配符形式更为简洁，但上面两种通配符都有一个重要的限制：只能读，不能写。怎么理解呢？看下面的例子：

```java
        DynamicArray<Integer> ints = new DynamicArray<>();
        DynamicArray<? extends Number> numbers = ints;
        Integer a = 200;
        numbers.add(a); //错误！
        numbers.add((Number)a); //错误！
        numbers.add((Object)a); //错误！
```

三种add方法都是非法的，无论是Integer，还是Number或Object，编译器都会报错。为什么呢？问号就是表示类型安全无知，? extends Number表示是Number的某个子类型，但不知道具体子类型，如果允许写入，Java就无法确保类型安全性，所以干脆禁止。我们来看个例子，看看如果允许写入会发生什么：

```java
        DynamicArray<Integer> ints = new DynamicArray<>();
        DynamicArray<? extends Number> numbers = ints;
        Number n = new Double(23.0);
        Object o = new String("hello world");
        numbers.add(n);
        numbers.add(o);
```

如果允许写入Object或Number类型，则最后两行编译就是正确的，也就是说，Java将允许把Double或String对象放入Integer容器，这显然违背了Java关于类型安全的承诺。

大部分情况下，这种限制是好的，但这使得一些理应正确的基本操作无法完成，比如交换两个元素的位置，看如下代码：

```java
        public static void swap(DynamicArray<? > arr, int i, int j){
            Object tmp = arr.get(i);
            arr.set(i, arr.get(j));
            arr.set(j, tmp);
        }
```

这个代码看上去应该是正确的，但Java会提示编译错误，两行set语句都是非法的。不过，借助带类型参数的泛型方法，这个问题可以如下解决：

```java
        private static <T> void swapInternal(DynamicArray<T> arr, int i, int j){
            T tmp = arr.get(i);
            arr.set(i, arr.get(j));
            arr.set(j, tmp);
        }
        public static void swap(DynamicArray<? > arr, int i, int j){
            swapInternal(arr, i, j);
        }
```

swap可以调用swapInternal，而带类型参数的swapInternal可以写入。Java容器类中就有类似这样的用法，公共的API是通配符形式，形式更简单，但内部调用带类型参数的方法。

除了这种需要写的场合，如果参数类型之间有依赖关系，也只能用类型参数，比如，将src容器中的内容复制到dest中：

```java
        public static <D, S extends D> void copy(DynamicArray<D> dest,
                DynamicArray<S> src){
            for(int i=0; i<src.size(); i++){
                dest.add(src.get(i));
            }
        }
```

S和D有依赖关系，要么相同，要么S是D的子类，否则类型不兼容，有编译错误。不过，上面的声明可以使用通配符简化，两个参数可以简化为一个，如下所示：

```java
        public static <D> void copy(DynamicArray<D> dest,
                DynamicArray<? extends D> src){
            for(int i=0; i<src.size(); i++){
                dest.add(src.get(i));
            }
        }
```

如果返回值依赖于类型参数，也不能用通配符，比如，计算动态数组中的最大值，如下所示：

```java
        public static <T extends Comparable<T>> T max(DynamicArray<T> arr){
            T max = arr.get(0);
            for(int i=1; i<arr.size(); i++){
                if(arr.get(i).compareTo(max)>0){
                    max = arr.get(i);
                }
            }
            return max;
        }
```

上面的代码就难以用通配符代替。

现在我们再来看泛型方法到底应该用通配符的形式还是加类型参数。两者到底有什么关系？我们总结如下。

1）通配符形式都可以用类型参数的形式来替代，通配符能做的，用类型参数都能做。

2）通配符形式可以减少类型参数，形式上往往更为简单，可读性也更好，所以，能用通配符的就用通配符。

3）如果类型参数之间有依赖关系，或者返回值依赖类型参数，或者需要写操作，则只能用类型参数。

4）通配符形式和类型参数往往配合使用，比如，上面的copy方法，定义必要的类型参数，使用通配符表达依赖，并接受更广泛的数据类型。

### 3、超类型通配符

还有一种通配符，与形式<? extends E>正好相反，它的形式为<? super E>，称为超类型通配符，表示E的某个父类型。它有什么用呢？有了它，我们就可以更灵活地写入了。

如果没有这种语法，写入会有一些限制。来看个例子，我们给DynamicArray添加一个方法：

```java
        public void copyTo(DynamicArray<E> dest){
            for(int i=0; i<size; i++){
                dest.add(get(i));
            }
        }
```

这个方法也很简单，将当前容器中的元素添加到传入的目标容器中。我们可能希望这么使用：

```java
        DynamicArray<Integer> ints = new DynamicArray<Integer>();
        ints.add(100);
        ints.add(34);
        DynamicArray<Number> numbers = new DynamicArray<Number>();
        ints.copyTo(numbers);
```

Integer是Number的子类，将Integer对象拷贝入Number容器，这种用法应该是合情合理的，但Java会提示编译错误，理由我们之前也说过了，期望的参数类型是Dynamic-Array<Integer>,DynamicArray<Number>并不适用。

如之前所说，一般而言，不能将DynamicArray<Integer>看作DynamicArray<Number>，但我们这里的用法是没有问题的，Java解决这个问题的方法就是超类型通配符，可以将copyTo代码改为：

```java
        public void copyTo(DynamicArray<? super E> dest){
            for(int i=0; i<size; i++){
                dest.add(get(i));
            }
        }
```

这样，就没有问题了。

超类型通配符另一个常用的场合是Comparable/Comparator接口。同样，我们先来看下如果不使用会有什么限制。以前面计算最大值的方法为例，它的方法声明是：

```java
        public static <T extends Comparable<T>> T max(DynamicArray<T> arr)
```

这个声明有什么限制呢？举个简单的例子，有两个类Base和Child, Base的代码是：

```java
        class Base implements Comparable<Base>{
            private int sortOrder;
            public Base(int sortOrder) {
                this.sortOrder = sortOrder;
            }
            @Override
            public int compareTo(Base o) {
                if(sortOrder < o.sortOrder){
                    return -1;
                }else if(sortOrder > o.sortOrder){
                    return 1;
                }else{
                    return 0;
                }
            }
        }
```

Base代码很简单，实现了Comparable接口，根据实例变量sortOrder进行比较。Child代码是：

```java
        class Child extends Base {
            public Child(int sortOrder) {
                super(sortOrder);
            }
        }
```

这里，Child非常简单，只是继承了Base。注意：Child没有重新实现Comparable接口，因为Child的比较规则和Base是一样的。我们可能希望使用前面的max方法操作Child容器，如下所示：

```java
        DynamicArray<Child> childs = new DynamicArray<Child>();
        childs.add(new Child(20));
        childs.add(new Child(80));
        Child maxChild = max(childs);
```

遗憾的是，Java会提示编译错误，类型不匹配。为什么不匹配呢？我们可能会认为，Java会将max方法的类型参数T推断为Child类型，但类型T的要求是extends Comparable<T>，而Child并没有实现Comparable<Child>，它实现的是Comparable<Base>。

但我们的需求是合理的，Base类的代码已经有了关于比较所需要的全部数据，它应该可以用于比较Child对象。解决这个问题的方法，就是修改max的方法声明，使用超类型通配符，如下所示：

```java
        public static <T extends Comparable<? super T>> T max(DynamicArray<T> arr)
```

这么修改一下就可以了，这种写法比较抽象，将T替换为Child，就是：

Child extends Comparable<? super Child>

<? super Child>可以匹配Base，所以整体就是匹配的。

我们比较一下类型参数限定与超类型通配符，类型参数限定只有extends形式，没有super形式，比如，前面的copyTo方法的通配符形式的声明为：

```java
        public void copyTo(DynamicArray<? super E> dest)
```

如果类型参数限定支持super形式，则应该是：

```java
        public <T super E> void copyTo(DynamicArray<T> dest)
```

事实是，Java并不支持这种语法。

前面我们说过，对于有限定的通配符形式<? extends E>，可以用类型参数限定替代，但是对于类似上面的超类型通配符，则无法用类型参数替代。

### 4、通配符比较

本节介绍了泛型中的三种通配符形式<? >、<? super E>和<? extends E>，并分析了与类型参数形式的区别和联系，它们比较容易混淆，我们总结比较如下：

1）它们的目的都是为了使方法接口更为灵活，可以接受更为广泛的类型。

2）<? super E>用于灵活写入或比较，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象，它不能被类型参数形式替代。

3）<? >和<? extends E>用于灵活读取，使得方法可以读取E或E的任意子类型的容器对象，它们可以用类型参数的形式替代，但通配符形式更为简洁。

Java容器类的实现中，有很多使用通配符的例子，比如，类Collections中就有如下方法：

```java
        public static <T extends Comparable<? super T>> void sort(List<T> list)
        public static <T> void sort(List<T> list, Comparator<? super T> c)
        public static <T> void copy(List<? super T> dest, List<? extends T> src)
        public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp)
```

通过前面两节，我们应该可以理解这些方法声明的含义了。关于泛型，还有一些细节以及限制，让我们下一节继续探讨。

## 三、细节和局限性

本节介绍泛型中的一些细节和局限性，这些局限性主要与Java的实现机制有关。Java中，泛型是通过类型擦除来实现的，类型参数在编译时会被替换为Object，运行时Java虚拟机不知道泛型这回事，这带来了很多局限性，其中有的部分是比较容易理解的，有的则是非常违反直觉的。

一项技术，往往只有理解了其局限性，才算是真正理解了它，才能更好地应用它。

### 1、使用泛型类、方法和接口

在使用泛型类、方法和接口时，有一些值得注意的地方，比如：

- 基本类型不能用于实例化类型参数。
- 运行时类型信息不适用于泛型。
- 类型擦除可能会引发一些冲突。

### 2、定义泛型类、方法和接口

在定义泛型类、方法和接口时，也有一些需要注意的地方，比如：

- 不能通过类型参数创建对象。
- 泛型类类型参数不能用于静态变量和方法。
- 了解多个类型限定的语法。

### 3、泛型与数组

- Java不支持创建泛型数组。
- 如果要存放泛型对象，可以使用原始类型的数组，或者使用泛型容器。
- 泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射。