# Java内置锁

参考：[Java高并发核心编程（卷2）：多线程、锁、JMM、JUC、高并发设计模式-尼恩编著-微信读书 (qq.com)](https://weread.qq.com/web/reader/9b93254072456ac19b9a176k28d32de024d28dd2c795c7f)

[TOC]

在**JDK 1.6版本**之前，所有的**Java内置锁**都是**重量级锁**。重量级锁会造成CPU在用户态和核心态之间的频繁切换，所有**代价高**、**效率低**。

在JDK 1.6版本中内置锁一共有四种状态：**无锁状态**、**偏向锁状态**、**轻量级锁状态**和**重量级锁状态**，这些状态随着竞争情况逐渐升级。

内置锁**可以升级但不能降级**，目的是提高获得锁和释放锁的效率。

## 一、无锁、偏向锁、轻量级锁、重量级锁

### 1、无锁状态

Java对象刚创建时还没有任何线程来竞争，说明该对象处于无锁状态（无线程竞争它）这时偏向锁标识位是0，锁状态是01。

<img src="assets/epub_38103745_37" alt="img" style="zoom: 67%;" />

### 2、偏向锁状态

偏向锁是指一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，减低获取锁的代价，如果内置锁处于偏向状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率非常高。

偏向锁状态的Mark Word会记录内置锁自己偏爱的线程ID，内置锁会将该线程当作自己的熟人。偏向锁状态下对象的Mark Word如图2-8所示。

<img src="D:\Github\misxzaiz.github.io\K\blog\note\Java\内置锁\assets\epub_38103745_38" alt="img" style="zoom:67%;" />

### 3、轻量级锁状态

当有两个线程开始竞争这个锁对象时，情况就发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象，锁对象的Mark Word就指向哪个线程的栈帧中的锁记录。轻量级锁状态下对象的Mark Word如图2-9所示。

<img src="D:\Github\misxzaiz.github.io\K\blog\note\Java\内置锁\assets\epub_38103745_39" alt="img" style="zoom:67%;" />

当锁处于偏向锁，又被另一个线程企图抢占时，偏向锁就会升级为轻量级锁。**企图抢占的线程会通过自旋的形式尝试获取锁**，不会阻塞抢锁线程，以便提高性能。

**自旋原理**非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换来进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就**避免了用户线程和内核切换的消耗**。

但是，线程自旋是需要消耗CPU的，如果一直获取不到锁，那么线程也不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM对于自旋周期的选择，JDK 1.6之后引入了**适应性自旋锁**，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的。线程如果自旋成功了，下次自旋的次数就会更多，如果自旋失败了，自旋的次数就会减少。

如果持有锁的线程执行的时间**超过自旋等待的最大时间**仍没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，自旋不会一直持续下去，这时争用线程会停止自旋进入**阻塞状态**，该锁膨胀为**重量级锁**。

### 4、重量级锁状态

重量级锁会让其他申请的线程之间进入**阻塞**，**性能降低**。重量级锁也叫**同步锁**，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队的线程。重量级锁状态下对象的Mark Word如图2-10所示。

<img src="D:\Github\misxzaiz.github.io\K\blog\note\Java\内置锁\assets\epub_38103745_40" alt="img" style="zoom:67%;" />

## 