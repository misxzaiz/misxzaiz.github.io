# 线程安全问题

参考资料：[《Java高并发核心编程（卷2）》](https://weread.qq.com/web/bookDetail/9b93254072456ac19b9a176)

[TOC]

**线程安全**：当多个线程并发访问某个Java对象（Object）时，无论系统如何调度这些线程，也无论这些线程将如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的。

## 一、自增运算不是线程安全的

### 1、线程安全测试

```java
public class NotSafePlus {
    private Integer amount = 0;
    public void selfPlus() {
        amount ++;
    }
    public Integer getAmount() {
        return amount;
    }
}
```

```java
import java.util.concurrent.CountDownLatch;

public class Demo {

    static final int MAX_TREAD = 10;
    static final int MAX_TURN = 1000;

    public static void main(String[] args) throws InterruptedException {
        // 倒数闩，需要倒数 MAX_TREAD 次
        CountDownLatch latch = new CountDownLatch(MAX_TREAD);
        NotSafePlus notSafePlus = new NotSafePlus();
        Runnable runnable = () -> {
            for (int i = 0; i < MAX_TURN; i++) {
                notSafePlus.selfPlus();
            }
            // 倒数闩减少一次
            latch.countDown();
        };
        for (int i = 0; i < MAX_TREAD; i++) {
            new Thread(runnable).start();
        }
        // 等待倒数闩的次数减少到 0，所有的线程执行完成
        latch.await();
        System.out.println("预期结果：" + MAX_TREAD * MAX_TURN);
        System.out.println("实际结果：" + notSafePlus.getAmount());
    }
}
```

```java
预期结果：10000
实际结果：3199
```

解决：

**在NotSafePlus类的selfPlus方法的返回值类型前添加synchronized关键字：**

```java
    public synchronized void selfPlus() {
        amount ++;
    }
```



为了获得10个线程的结果，主线程通过CountDownLatch（倒数闩）工具类进行了并发线程的等待。

CountDownLatch（倒数闩）是一个非常实用的等待多线程并发的工具类。调用线程可以在倒数闩上进行等待，一直等待倒数闩的次数减少到0，才继续往下执行。每一个被等待的线程执行完成之后进行一次倒数。所有被等待的线程执行完成之后，倒数闩的次数减少到0，调用线程可以往下执行，从而达到并发等待的效果。

### 2、原因分析

自增运算符是一个复合操作，至少包括三个 JVM 指令：“内存取值”、“寄存器增加1”和“存值到内存”。这三个指令在 JVM 内部是独立进行的，中间完全可能会出现多个线程并发进行。

比如在amount=100时，假设有三个线程同一时间读取amount值，读到的都是100，增加1后结果为101，三个线程都将结果存入amount的内存，amount的结果是101，而不是103。

“内存取值”“寄存器增加1”和“存值到内存”这三个JVM指令本身是不可再分的，它们都具备原子性，是线程安全的，也叫**原子操作**。但是，两个或者两个以上的原子操作合在一起进行操作就不再具备原子性了。比如先读后写，就有可能在读之后，其实这个变量被修改了，出现读和写数据不一致的情况。

## 二、临界区资源与临界区代码段

Java工程师在进行代码开发时，常常倾向于认为代码会以线性的、串行的方式执行，容易忽视多个线程并行执行，从而导致意想不到的结果。

一般来说，只在多个线程对这个资源进行写操作的时候才会出现问题，如果是简单的读操作，不改变资源的话，显然是不会出现问题的。

**临界区资源**表示一种可以被多个线程使用的公共资源或共享数据，但是每一次只能有一个线程使用它。一旦临界区资源被占用，想使用该资源的其他线程则必须等待。

在并发情况下，临界区资源是受保护的对象。**临界区代码段（Critical Section）**是每个线程中访问临界资源的那段代码，多个线程必须互斥地对临界区资源进行访问。线程进入临界区代码段之前，必须在进入区申请资源，申请成功之后执行临界区代码段，执行完成之后释放资源。

![img](assets/epub_38103745_26)

**竞态条件（Race Conditions）**可能是由于在访问临界区代码段时没有互斥地访问而导致的特殊情况。如果多个线程在临界区代码段的并发执行结果可能因为代码的执行顺序不同而不同，我们就说这时在临界区出现了竞态条件问题。

在前面的线程安全小实验的代码中，amount为临界区资源，selfPlus()可以理解为临界区代码段。

为了避免竞态条件的问题，我们必须保证临界区代码段操作具备排他性。这就意味着当一个线程进入临界区代码段执行时，其他线程不能进入临界区代码段执行。

在Java中，我们可以使用**synchronized关键字同步代码块**，**对临界区代码段进行排他性保护**，示意代码如下：

```java
synchronized(syncObject) {
    // critical section
}
```



在Java中，使用synchronized关键字还可以使用**Lock显式锁**实例，或者使用**原子变量（Atomic Variables）**对临界区代码段进行排他性保护。
