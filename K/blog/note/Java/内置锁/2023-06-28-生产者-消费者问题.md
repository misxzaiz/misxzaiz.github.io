---
key-word:
  - 生产者-消费者问题
---



# 生产者-消费者问题

参考资料：[《Java高并发核心编程（卷2）》](https://weread.qq.com/web/bookDetail/9b93254072456ac19b9a176)

[TOC]

**生产者-消费者问题（Producer-Consumer Problem）**也称**有限缓冲问题（Bounded-Buffer Problem）**，是一个多线程同步问题的经典案例。

## 一、生产者-消费者问题

生产者-消费者问题的关键是：

（1）保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据。

（2）保证在生产者加入过程、消费者消耗过程中，不会产生错误的数据和行为。

生产者-消费者问题不仅仅是一个多线程同步问题的经典案例，而且业内已经将解决该问题的方案抽象成了一种设计模式——“生产者-消费者”模式。“生产者-消费者”模式是一个经典的多线程设计模式，它为多线程间的协作提供了良好的解决方案。

### 1、生产者-消费者模式

在生产者-消费者模式中，通常有两类线程，即**生产者线程**（若干个）和**消费者线程**（若干个）。生产者线程向**数据缓冲区（DataBuffer）**加入数据，消费者线程则从数据缓冲区消耗数据。

在生产者-消费者模式中，至少有以下关键点：

（1）生产者与生产者之间、消费者与消费者之间，**对数据缓冲区的操作是并发进行的**。

（2）数据缓冲区是有容量上限的。数据缓冲区满后，生产者不能再加入数据；数据缓冲区空时，消费者不能再取出数据。

（3）数据缓冲区是线程安全的。在并发操作数据缓冲区的过程中，**不能出现数据不一致的情况**；或者在多个线程并发更改共享数据后，**不会造成出现脏数据的情况**。

（4）生产者或者消费者线程在空闲时需要**尽可能阻塞而不是执行无效的空操作**，尽量节约CPU资源。

> 阻塞操作可以节约CPU资源的原因在于它避免了空操作循环，从而减少了CPU的空闲时间和功耗消耗。
>
> 在没有阻塞操作的情况下，如果需要等待某个事件或条件满足时，通常会使用空操作循环（busy waiting）来检查该事件或条件是否已经满足。这种循环会持续占用CPU的执行时间，并且会导致CPU进行大量的无用操作，浪费了宝贵的计算资源。
>
> 相比而言，使用阻塞操作的方式能够有效地利用CPU资源。当执行阻塞操作时，它会将控制权交还给操作系统，告知自己暂时不需要CPU资源。操作系统会将这个进程或线程置于睡眠状态，直到阻塞操作完成或达到某个条件。在这段期间，操作系统可以将CPU分配给其他进程或线程，从而提高整体系统的资源利用率。
>
> 总而言之，通过使用阻塞操作，我们能够让CPU在等待某个事件或条件的过程中得到有效的休息，避免了无谓的空操作循环，从而节约了CPU资源并降低了功耗消耗。这对于提高系统的性能和效率非常重要。

### 2、一个线程不安全的实现版本

根据上面对生产者-消费者问题的描述先来实现一个非线程安全版本，包含数据缓冲区（DataBuffer）类、生产者（Producer）类和消费者（Consumer）类。

#### 线程缓冲区类

DataBuffer类型的实例属性**dataList**保存具体数据元素，实例属性**amount**保存元素的数量。

DataBuffer类型有两个实例方法，实例方法**add()**用于向数据区增加元素，实例方法**fetch()**用于从数据区消耗元素。

在add()实例方法中，加入元素之前首先会对amount是否达到上限进行判断，如果数据区满了，就不能加入数据；

在fetch()实例方法中，消耗元素前首先会对amount是否大于零进行判断，如果数据区空了，就不能取出数据。

```java
package org.example.demo.pc;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

//数据缓冲区，不安全版本的类定义
class NotSafeDataBuffer<T>
{
    public static final int MAX_AMOUNT = 10;
    private List<T> dataList = new LinkedList<>();

    //保存数量
    private AtomicInteger amount = new AtomicInteger(0);

    //向数据区增加一个元素
    public void add(T element) throws Exception
    {
        if (amount.get() > MAX_AMOUNT)
        {
            System.out.println("队列已经满了！");
            return;
        }
        dataList.add(element);
        System.out.println(String.valueOf(element));
        amount.incrementAndGet();

        //如果数据不一致，就抛出异常
        if (amount.get() != dataList.size())
        {
            throw new Exception(amount + "!=" + dataList.size());
        }
    }

    //从数据区取出一个元素
    public T fetch() throws Exception
    {
        if (amount.get() <= 0)
        {
            System.out.println("队列已经空了！");
            return null;
        }
        T element = dataList.remove(0);
        System.out.println(String.valueOf(element));
        amount.decrementAndGet();
        //如果数据不一致，就抛出异常
        if (amount.get() != dataList.size())
        {
            throw new Exception(amount + "!=" + dataList.size());
        }
        return element;
    }
}
```

#### 生产者、消费者的逻辑与动作解耦

生产者-消费者模式在本书中有多个不同版本的实现，这些版本的区别在于数据缓冲区（DataBuffer）类以及相应的生产、消费动作（Action）不同，而生产者类、消费者类的执行逻辑是相同的。“分离变与不变”是软件设计的一个基本原则。现在将生产者类、消费者类与具体的生产、消费动作解耦，从而使得生产者类、消费者类的代码在后续可以复用。

“分离变与不变”原则的背后蕴藏着丰富的软件工程思想，例如信息的分装与隐藏、系统的模块化、使用分层构架等。其中，“变”是指易变的代码或者模块，“不变”就是指系统中不易变化的部分。在解耦后的生产者-消费者模式结构中，不变的部分为生产者（Producer）类和消费者（Consumer）类，后续可以直接复用，不需要修改代码；变化的部分为数据缓冲区（DataBuffer）类以及相应的生产和消费动作，后续不同的生产者-消费者实现版本只要编写各自的DataBuffer和Action实现即可。

#### 通用的Producer类实现

通用的Producer类组合了一个Callable类型的成员action实例，代表了生产数据所需要执行的实际动作，需要在构造Producer实例时传入。

```java
package org.example.demo.pc;

import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicInteger;

public class Producer implements Runnable{

    // 生产的时间间隔，生产一次等待的时间默认为200毫秒
    public static final int PRODUCE_GAP = 200;

    // 总次数
    static final AtomicInteger TURN = new AtomicInteger(0);

    // 生产者对象编号
    static final AtomicInteger PRODUCER_NO = new AtomicInteger(1);

    // 生产者名称
    String name = null;

    // 生产者的动作
    Callable action = null;

    int gap = PRODUCE_GAP;

    public Producer(Callable action, int gap) {
        this.action = action;
        this.gap = gap;
        name = "生产者-" + PRODUCER_NO.incrementAndGet();
    }

    @Override
    public void run() {
        while (true) {
            try {
                // 执行生产动作
                Object out = action.call();
                // 输出生产的结果
                if (out != null) {
                    System.out.println("第" + TURN.get() + "轮生产：" + out);
                }
                // 增加生产轮次
                TURN.incrementAndGet();
            } catch (Exception e) {
                // 在控制台输出异常的类型、消息以及异常发生的位置等详细信息。
                e.printStackTrace();
            }
        }
    }
}
```



#### 通用的Consumer类实现

通用的Consumer类组合了一个Callable类型的成员action实例，代表了消费者所需要执行的实际消耗动作，需要在构造Consumer实例时传入。

```java
package org.example.demo.pc;

import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 通用的消费者的定义
 */
public class Consumer implements Runnable
{

    //消费的时间间隔，默认等待100毫秒
    public static final int CONSUME_GAP = 100;
    //消费总次数
    static final AtomicInteger TURN = new AtomicInteger(0);
    //消费者对象编号
    static final AtomicInteger CONSUMER_NO = new AtomicInteger(1);
    //消费者名称
    String name;
    //消费的动作
    Callable action = null;

    //消费一次等待的时间，默认为100毫秒
    int gap = CONSUME_GAP;

    public Consumer(Callable action, int gap)
    {
        this.action = action;
        this.gap = gap;
        name = "消费者-" + CONSUMER_NO.incrementAndGet();

    }

    @Override
    public void run()
    {
        while (true)
        {
            //增加消费次数
            TURN.incrementAndGet();
            try
            {
                //执行消费动作
                Object out = action.call();
                if (null != out)
                {
                    System.out.println(+ TURN.get() + "轮消费：" + out);
                }
                //每一轮消费之后，稍微等待一下
                Thread.sleep(gap*1000);
            } catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}
```



#### 数据区缓冲区实例、生产动作、消费动作的定义

在完成了数据缓冲区类的定义、生产者类的定义、消费者类的定义之后，接下来定义一下数据缓冲区实例、生产动作和消费动作，具体的代码如下：

```java
package org.example.demo.pc;

import java.util.concurrent.Callable;

public class NotSafePetStore {
    // 数据缓冲区的静态实例
    private static NotSafeDataBuffer<String> notSafeDataBuffer = new NotSafeDataBuffer<>();

    // 生产者执行的动作
    static Callable<String> produceAction = () -> {
        String goods = "商品" + Math.random();
        try {
            notSafeDataBuffer.add(goods);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return goods;
    };

    // 消费者执行的动作
    static Callable<String> consumerAction = () -> {
        String goods = null;
        try {
            goods = notSafeDataBuffer.fetch();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return goods;
    };
}
```



#### 组装出一个生产者和消费者模式的简单实现版本

利用以上NotSafePetStore类所定义的三个静态成员可以快速组装出一个简单的生产者和消费者模式的Java实现版本，具体的代码如下：

```java
package org.example.demo.pc;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class NotSafePetStore {

    public static void main(String[] args) {
        // 同时并发执行的线程数
        final int THREAD_TOTAL = 20;
        // 线程池，用于模拟多线程测试
        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);
        for (int i = 0; i < 5; i++) {
            // 生产者实例每生产一个商品，间隔500毫秒
            threadPool.submit(new Producer(produceAction, 500));
            // 消费者实例每消费一个商品，间隔1500毫秒
            threadPool.submit(new Consumer(consumerAction, 1500));
        }
    }
}
```

这是存在问题的。

```java
package org.example.demo.pc;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class NotSafePetStore {

    public static void main(String[] args) {
        // 同时并发执行的线程数
        final int THREAD_TOTAL = 20;
        // 线程池，用于模拟多线程测试
        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_TOTAL);
        for (int i = 0; i < 5; i++) {
            // 生产者实例每生产一个商品，间隔500毫秒
            threadPool.submit(new Producer(produceAction, 500));
            // 消费者实例每消费一个商品，间隔1500毫秒
            threadPool.submit(new Consumer(consumerAction, 1500));
        }
    }
```

### 3、一个线程安全的实现版本

在上一个版本的生产者-消费者问题的实现中，由于线程安全问题，导致数据区的amount属性和dataList的长度在数据值上差别巨大。

解决线程安全问题很简单，为临界区代码加上synchronized关键字即可，主要修改的是涉及操作两个临界区资源amount和dataList的代码，具体为DataBuffer的add(…)和fetch()方法。

创建一个安全的数据缓存区类SafeDataBuffer，在其add(…)和fetch()两个实例方法的public声明后面加上synchronized关键字即可。

虽然线程安全问题顺利解决了，但是以上解决方式使用了SafeDataBuffer实例的对象锁作为同步锁，这样一来，所有的生产、消费动作在执行过程中都需要抢占同一个同步锁，最终的结果是所有的生产、消费动作都被串行化了。

高效率的生产者-消费者模式，生产、消费动作肯定不能串行执行，而是需要并行执行，而且并行化程度越高越好。如何既保障没有线程安全问题，又能提高生产、消费动作的并行化程度呢？这就是本书后续的实现版本需要解决的问题。

如果需要开发出并行化程度更高的生产者-消费者模式实现版本，需要彻底地掌握和理解对象锁、synchronized等机制的内部原理，这就需要从Java对象的头部结构等基础知识学起。