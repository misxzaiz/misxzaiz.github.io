# 多线程

| 概念 | 说明 |
| ---- | ---- |
| 并发 |      |
| 并行 |      |
| 进程 |      |
| 线程 |      |



## 实现方式

| 实现方式      | 说明           |
| ------------- | -------------- |
| 继承 Thread   |                |
| 实现 Runnable |                |
| 实现 Callable | 可以带有返回值 |

### 1、继承 Thread

```java
package org.example;

import org.junit.jupiter.api.Test;

public class CreateThreadTest {

    // 静态内部类
    public static class MyThread extends Thread {
        @Override
        public void run(){
            System.out.println("【线程】线程名："+getName()+"\t线程id："+getId());
        }
    }

    @Test
    public void createThreadTest(){
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();

        myThread1.setName("线程1");
        myThread2.setName("线程2");

        myThread1.start();
        myThread2.start();
        // 直接新建线程并执行
        new MyThread().start();
    }
}
```

```
【线程】线程名：线程1	线程id：13
【线程】线程名：线程2	线程id：14
【线程】线程名：Thread-3	线程id：15
```

### 2、实现 Runnable

```java
    // 2. 实现 Runnable
    // 静态内部类
    public static class MyRunnable implements Runnable {
        @Override
        public void run(){
            Thread t = Thread.currentThread();
            System.out.println("【线程】线程名："+t.getName()+"\t线程id："+t.getId());
        }
    }

    @Test
    public void createThreadWithRunnableTest(){
        // 创建 MyRunnable 对象
        MyRunnable myRunnable = new MyRunnable();
        // 创建线程对象
        Thread myThread1 = new Thread(myRunnable);
        Thread myThread2 = new Thread(myRunnable);
        myThread1.setName("线程1");
        myThread2.setName("线程2");

        myThread1.start();
        myThread2.start();
        new Thread(myRunnable).start();
    }
```

```java
【线程】线程名：线程1	线程id：13
【线程】线程名：线程2	线程id：14
【线程】线程名：Thread-3	线程id：15
```

### 3、实现 Callable

1. 创建一个类 MyCallable 实现 Callable 接口
2. 重写 call 方法（带有返回值）
3. 创建 MyCallable 对象（表示多线程要执行的任务）
4. 创建 FutureTask 对象（作用管理多线程运行的结果）
5. 创建 Thread 类的对象，并启动

```java
    // 3. 实现 Callable
    // 静态内部类
    public static class MyCallable implements Callable {
        @Override
        public String call(){
            Thread t = Thread.currentThread();
            return t.getName();
        }
    }

    @Test
    public void createThreadWithCallableTest() throws ExecutionException, InterruptedException {
        // 创建 MyRunnable 对象
        MyCallable myRunnable = new MyCallable();
        // 创建 FutureTask 对象
        FutureTask<String> ft1 = new FutureTask<>(myRunnable);
        FutureTask<String> ft2 = new FutureTask<>(myRunnable);
        // 创建线程对象
        Thread t1 = new Thread(ft1);
        Thread t2 = new Thread(ft2);
        t1.start();
        t2.start();
        System.out.println("【Callable】返回值："+ft1.get());
        System.out.println("【Callable】返回值："+ft2.get());
    }
```

```
【Callable】返回值：Thread-1
【Callable】返回值：Thread-2
```

## Thread 的成员方法

下面是使用Markdown表格总结了Java中`Thread`类常用的方法。

这些方法使得我们可以通过`Thread`类来控制线程的启动、运行、暂停、终止等操作，方便实现多线程编程。

### 1、静态方法
| 方法                             | 描述                                       |
| -------------------------------- | ------------------------------------------ |
| `static void sleep(long millis)` | 使当前线程**休眠**指定的毫秒数             |
| `static void yield()`            | 出让/礼让线程                              |
| `static void join()`             | 插入/插队线程                              |
| `static Thread currentThread()`  | 返回当前正在执行的线程的引用               |
| `static boolean interrupted()`   | 测试当前线程是否已经中断，并会清除中断状态 |


### 2、其他方法

| 方法                                | 描述                                                       |
| ----------------------------------- | ---------------------------------------------------------- |
| `void start()`                      | 启动线程，调用线程的`run()`方法                            |
| `void run()`                        | 线程执行的逻辑代码，在`Thread`类中是空的，需要子类重写实现 |
| `void join()`                       | 等待该线程终止                                             |
| `void interrupt()`                  | 中断线程，给线程发送中断信号                               |
| `boolean isAlive()`                 | 判断线程是否存活                                           |
| `void setName(String name)`         | 设置线程的名称                                             |
| `String getName()`                  | 获取线程的名称                                             |
| `void setPriority(int priority)`    | 设置线程的优先级                                           |
| `int getPriority()`                 | 获取线程的优先级                                           |
| `void setDaemon(boolean on)`        | 设置线程是否为守护线程                                     |
| `boolean isDaemon()`                | 判断线程是否为守护线程                                     |
| `void interrupted()`                | 测试当前线程是否已经中断，并会清除中断状态                 |
| `boolean isInterrupted()`           | 测试线程是否已经中断                                       |
| `void join(long millis)`            | 等待该线程终止的最长时间为 millis 毫秒                     |
| `void join(long millis, int nanos)` | 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒        |

### 3、使用构造方法设置线程名

重写父类构造方法

```java
    public static class MyThread extends Thread {
        public MyThread() {
        }

        public MyThread(String name) {
            super(name);
        }

        @Override
        public void run(){
            System.out.println("【线程】线程名："+getName()+"\t线程id："+getId());
        }
    }


    @Test
    public void createThreadTest() throws InterruptedException {
        MyThread myThread1 = new MyThread("线程1");
        myThread2.start();
    }
```

### 4、守护线程

当其他非守护线程执行完成后，守护线程会陆续结束。

## 生命周期

Java的Thread（线程）的生命周期通常包括以下几个状态：

1. 新建状态（New）：当创建一个Thread对象时，即进入新建状态。但是此时并未启动线程。

2. 运行状态（Runnable）：通过调用Thread对象的start()方法，使线程进入运行状态。此时线程并不一定立即执行，而是等待CPU资源的调度。

3. 阻塞状态（Blocked）：在线程运行过程中，可能会由于某些原因暂停执行，例如等待输入、等待某个资源等。在这种情况下，线程会进入阻塞状态，不再占用CPU资源。

4. 等待状态（Waiting）：线程可能会由于调用了wait()方法或join()方法等，主动放弃CPU资源，进入等待状态。

5. 时间等待状态（Timed Waiting）：类似于等待状态，但是有个限时等待的特点，可以通过设置等待时间来让线程在特定时间后自动恢复运行。

6. 终止状态（Terminated）：线程执行完成或者出现异常导致线程终止时，进入终止状态。

线程在不同状态间的转换如下：

1. 新建 -> 运行：调用start()方法。

2. 运行 -> 阻塞：等待某个条件的满足。

3. 运行 -> 等待：调用wait()方法，或者调用join()方法。

4. 运行 -> 时间等待：调用sleep()方法、wait()方法设置了超时时间，或者调用LockSupport.parkNanos()等方法。

5. 阻塞、等待、时间等待 -> 运行：满足相应的条件，如获取到了资源、被notify()或notifyAll()唤醒。

6. 运行 -> 终止：run()方法执行完毕，或者抛出异常导致线程终止。

需要注意的是，线程的状态转换可能会受到外部因素的影响，如CPU调度、对象的锁等。

## 线程安全

### 1、买票

```java
package org.example;

import org.junit.jupiter.api.Test;

public class ThreadSafeTest {
    public static class TicketSeller implements Runnable {
        private int tickets = 100;

        @Override
        public void run() {
            // 先循环在同步，避免一直锁定
            while (tickets > 0) {
                // 同步代码块，确保只有一个线程可以进入，避免并发问题
                // synchronized (this) {
                synchronized (TicketSeller.class) {
                    if (tickets > 0) {
                        System.out.println(Thread.currentThread().getName() + " 卖出第 " + tickets + " 张票");
                        tickets--;
                    }
                }
                try {
                    // 线程休眠一段时间，模拟卖票过程
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    @Test
    public void testTicketSeller() throws InterruptedException {
        TicketSeller ticketSeller = new TicketSeller();

        // 创建并启动四个线程，模拟四个售票窗口
        Thread thread1 = new Thread(ticketSeller, "窗口1");
        Thread thread2 = new Thread(ticketSeller, "窗口2");
        Thread thread3 = new Thread(ticketSeller, "窗口3");
        Thread thread4 = new Thread(ticketSeller, "窗口4");
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();

        try {
            // 等待四个子线程执行完毕
            thread1.join();
            thread2.join();
            thread3.join();
            thread4.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("所有售票窗口已关闭");
    }
}

```

### 2、StringBuilder 和 StringBuffer

- StringBuffer 是线程安全的，他的方法带有 synchronized。

### 3、Lock

- lock.lock()

- lock.unlock()

```java
package org.example;

import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ThreadSafeTest {
    public static class TicketSeller implements Runnable {
        private int tickets = 100;

        Lock lock = new ReentrantLock();

        @Override
        public void run() {
            while (tickets > 0) {
                try {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() + " 卖出第 " + tickets + " 张票");
                    tickets--;
                } finally {
                    // 一定要释放锁
                    lock.unlock();
                }
                try {
                    // 线程休眠一段时间，模拟卖票过程
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    @Test
    public void testTicketSeller() throws InterruptedException {
        TicketSeller ticketSeller = new TicketSeller();
        // 创建并启动四个线程，模拟四个售票窗口
        Thread thread1 = new Thread(ticketSeller, "窗口1");
        Thread thread2 = new Thread(ticketSeller, "窗口2");
        Thread thread3 = new Thread(ticketSeller, "窗口3");
        Thread thread4 = new Thread(ticketSeller, "窗口4");
        System.out.println(LocalDateTime.now());
        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();

        try {
            // 等待四个子线程执行完毕
            thread1.join();
            thread2.join();
            thread3.join();
            thread4.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(LocalDateTime.now());
        System.out.println("所有售票窗口已关闭");
    }
}

```

### 4、死锁

```java
package org.example;

import org.junit.jupiter.api.Test;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class DeadLock {
    public static class MyThread extends Thread {
        static Object lockA = new Object();
        static Object lockB = new Object();

        @Override
        public void run() {
            while (true){
                if ("线程A".equals(getName())){
                    synchronized (lockA){
                        System.out.println("线程A获取lockA");
                        synchronized (lockB){
                            System.out.println("线程A获取lockB");
                        }
                    }
                }else if ("线程B".equals(getName())){
                    synchronized (lockB){
                        System.out.println("线程B获取lockB");
                        synchronized (lockA){
                            System.out.println("线程B获取lockA");
                        }
                    }
                }
            }
        }
    }

    @Test
    public void test() throws InterruptedException {
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        myThread1.setName("线程A");
        myThread2.setName("线程B");
        myThread1.start();
        myThread2.start();
        myThread1.join();
        myThread2.join();
    }
}
```

### 5、生产者和消费者（等待唤醒机制）

| 方法             | 说明                             |
| ---------------- | -------------------------------- |
| void wait()      | 当前线程等待，直到被其他线程唤醒 |
| void notify()    | 随机唤醒当个线程                 |
| void notifyAll() | 唤醒所有线程                     |

这段代码是一个经典的生产者-消费者问题的解决方案。下面是对代码的总结：

1. `ProducerConsumer` 类是实际执行生产者和消费者操作的类，它使用一个 `LinkedList` 作为缓冲区来存储数据，并定义了缓冲区的容量为 5。
2. `produce()` 方法是生产者线程执行的方法，它使用一个无限循环来不断地生产数据。在每次循环中，首先进入同步块，并检查缓冲区是否已满。如果已满，则调用 `wait()` 方法将当前线程挂起，直到有空间可用。然后，生产者生产一个值并将其添加到缓冲区中，同时打印出生产的值。最后，调用 `notify()` 方法唤醒可能正在等待的消费者线程，并在进入下一次循环之前使当前线程休眠1秒。
3. `consume()` 方法是消费者线程执行的方法，它也使用一个无限循环来不断地消费数据。在每次循环中，首先进入同步块，并检查缓冲区是否为空。如果为空，则调用 `wait()` 方法将当前线程挂起，直到有数据可用。然后，消费者从缓冲区中移除第一个值，并打印出消费的值。最后，调用 `notify()` 方法唤醒可能正在等待的生产者线程，并在进入下一次循环之前使当前线程休眠1秒。
4. `ProducerConsumerTest` 类是测试类，使用 JUnit 创建了一个测试方法 `test()`。在测试方法中，创建了一个 `ProducerConsumer` 实例，并创建了两个线程，一个用于执行生产者操作，另一个用于执行消费者操作。然后，启动这两个线程，并通过 `join()` 方法等待它们的完成。

整体而言，该代码实现了一个简单的生产者-消费者模型，其中生产者负责向缓冲区中生产数据，消费者负责从缓冲区中消费数据。通过使用同步块和 wait/notify 机制，确保在缓冲区满时生产者等待，缓冲区空时消费者等待，并且生产者和消费者之间能够正确地进行协作。

```java
package org.example;

import org.junit.jupiter.api.Test;

import java.util.LinkedList;

class ProducerConsumer {
    private LinkedList<Integer> buffer = new LinkedList<>();
    private int capacity = 5;

    public void produce() throws InterruptedException {
        int value = 0;
        while (true) {
            synchronized (this) {
                while (buffer.size() == capacity) {
                    wait();
                }

                System.out.println("Producer produced: " + value);
                buffer.add(value++);

                notify();

                Thread.sleep(1000);
            }
        }
    }

    public void consume() throws InterruptedException {
        while (true) {
            synchronized (this) {
                while (buffer.isEmpty()) {
                    wait();
                }

                int value = buffer.removeFirst();
                System.out.println("Consumer consumed: " + value);

                notify();

                Thread.sleep(1000);
            }
        }
    }
}

public class ProducerConsumerTest {
    @Test
    public void test() throws InterruptedException {
        ProducerConsumer pc = new ProducerConsumer();

        Thread producerThread = new Thread(() -> {
            try {
                pc.produce();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumerThread = new Thread(() -> {
            try {
                pc.consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producerThread.start();
        consumerThread.start();
        producerThread.join();
        consumerThread.join();
    }
}

```



