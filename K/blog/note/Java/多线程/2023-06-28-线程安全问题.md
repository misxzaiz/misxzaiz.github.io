# 线程安全问题

参考资料：[《Java高并发核心编程（卷2）》](https://weread.qq.com/web/bookDetail/9b93254072456ac19b9a176)

[TOC]

**线程安全**：当多个线程并发访问某个Java对象（Object）时，无论系统如何调度这些线程，也无论这些线程将如何交替操作，这个对象都能表现出一致的、正确的行为，那么对这个对象的操作是线程安全的。

## 一、自增运算不是线程安全的

### 1、线程安全测试

```java
public class NotSafePlus {
    private Integer amount = 0;
    public void selfPlus() {
        amount ++;
    }
    public Integer getAmount() {
        return amount;
    }
}
```

```java
import java.util.concurrent.CountDownLatch;

public class Demo {

    static final int MAX_TREAD = 10;
    static final int MAX_TURN = 1000;

    public static void main(String[] args) throws InterruptedException {
        // 倒数闩，需要倒数 MAX_TREAD 次
        CountDownLatch latch = new CountDownLatch(MAX_TREAD);
        NotSafePlus notSafePlus = new NotSafePlus();
        Runnable runnable = () -> {
            for (int i = 0; i < MAX_TURN; i++) {
                notSafePlus.selfPlus();
            }
            // 倒数闩减少一次
            latch.countDown();
        };
        for (int i = 0; i < MAX_TREAD; i++) {
            new Thread(runnable).start();
        }
        // 等待倒数闩的次数减少到 0，所有的线程执行完成
        latch.await();
        System.out.println("预期结果：" + MAX_TREAD * MAX_TURN);
        System.out.println("实际结果：" + notSafePlus.getAmount());
    }
}
```

```java
预期结果：10000
实际结果：3199
```

为了获得10个线程的结果，主线程通过CountDownLatch（倒数闩）工具类进行了并发线程的等待。

CountDownLatch（倒数闩）是一个非常实用的等待多线程并发的工具类。调用线程可以在倒数闩上进行等待，一直等待倒数闩的次数减少到0，才继续往下执行。每一个被等待的线程执行完成之后进行一次倒数。所有被等待的线程执行完成之后，倒数闩的次数减少到0，调用线程可以往下执行，从而达到并发等待的效果。

### 2、原因分析

自增运算符是一个复合操作，至少包括三个 JVM 指令：“内存取值”、“寄存器增加1”和“存值到内存”。这三个指令在 JVM 内部是独立进行的，中间完全可能会出现多个线程并发进行。

比如在amount=100时，假设有三个线程同一时间读取amount值，读到的都是100，增加1后结果为101，三个线程都将结果存入amount的内存，amount的结果是101，而不是103。

“内存取值”“寄存器增加1”和“存值到内存”这三个JVM指令本身是不可再分的，它们都具备原子性，是线程安全的，也叫**原子操作**。但是，两个或者两个以上的原子操作合在一起进行操作就不再具备原子性了。比如先读后写，就有可能在读之后，其实这个变量被修改了，出现读和写数据不一致的情况。
