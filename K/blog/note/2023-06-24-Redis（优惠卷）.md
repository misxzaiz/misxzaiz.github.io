实现

- 超卖问题
- 一人一单

## 一、数据表


```sql
DROP TABLE IF EXISTS `tb_voucher`;
CREATE TABLE `tb_voucher`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `shop_id` bigint(20) UNSIGNED NULL DEFAULT NULL COMMENT '商铺id',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '代金券标题',
  `sub_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '副标题',
  `rules` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '使用规则',
  `stock` int UNSIGNED NOT NULL DEFAULT 0 COMMENT '优惠卷数量',
  `pay_value` bigint(10) UNSIGNED NOT NULL COMMENT '支付金额，单位是分。例如200代表2元',
  `actual_value` bigint(10) NOT NULL COMMENT '抵扣金额，单位是分。例如200代表2元',
  `type` tinyint(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '0,普通券；1,秒杀券',
  `status` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '1,上架; 2,下架; 3,过期',
  `start_time` timestamp NOT NULL COMMENT '创建时间',
  `end_time` timestamp NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

INSERT INTO `tb_voucher` VALUES (1, 1, '80元代金券', '周一至周日均可使用', '全场通用\\n无需预约\\n可无限叠加\\不兑现、不找零\\n仅限堂食', 100, 10000, 8000, 1, 1, '2022-06-24 09:42:39', '2025-06-25 09:42:39');

DROP TABLE IF EXISTS `tb_voucher_order`;
CREATE TABLE `tb_voucher_order`  (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `user_id` bigint(20) UNSIGNED NOT NULL COMMENT '下单的用户id',
  `voucher_id` bigint(20) UNSIGNED NOT NULL COMMENT '购买的代金券id',
  `pay_type` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '支付方式 1：余额支付；2：支付宝；3：微信',
  `status` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '下单时间',
  `pay_time` timestamp NULL DEFAULT NULL COMMENT '支付时间',
  `use_time` timestamp NULL DEFAULT NULL COMMENT '核销时间',
  `refund_time` timestamp NULL DEFAULT NULL COMMENT '退款时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;
```

## 二、实体类

### Voucher

```java
package org.example.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.util.Date;

@Data
@TableName("tb_voucher")
public class Voucher {
    private Long id;
    private Long shopId;
    private String title;
    private String subTitle;
    private String rules;
    private Integer stock;
    private Long payValue;
    private Long actualValue;
    private Integer type;
    private Integer status;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date startTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date endTime;
}
```

### VoucherOrder

```java
package org.example.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.util.Date;

@Data
@TableName("tb_voucher_order")
public class VoucherOrder {
    private Long id;
    private Long userId;
    private Long voucherId;
    private Integer payType;
    private Integer status;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date payTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date useTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date refundTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updateTime;
}
```

## 三、抢购优惠卷

### 1、基本构成

1. 查询数据库
2. 检查是否在抢卷时间
3. 检查优惠卷数量是否充足
4. 扣减优惠卷数量
5. 保存优惠卷订单

```java
    @Override
    @Transactional
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);
        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 扣减优惠卷数量
        voucher.setStock(--stock);
        boolean updateMark = voucherService.updateById(voucher);
        if (!updateMark) return Result.fail("扣减失败！");
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单
        // 从当前线程获取用户 id
        UserDto user = UserHolder.getUser();
        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(user.getId());
        voucherOrder.setVoucherId(id);
        save(voucherOrder);
        return Result.ok("抢购成功！");
    }
```

### 2、超卖问题

版本号法：这里可以以库存为版本号

乐观锁：在更新时判断是否有其他线程在修改，存在成功率低问题

有些不能使用库存作为版本号，可能有一个人修改库存加一，然后又有一个人给库存减一，因此要以一个单独属性为版本号

```java
    @Override
    @Transactional
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);
        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 【版本号法】扣减优惠卷数量
        boolean update = voucherService.update()
                .setSql("stock = stock  - 1")
                .eq("id", id)
                // .eq("stock", stock) // 版本号法，失败了高
                .gt("stock",0) // stock > 0，实际业务，stock大于0就行
                .update();
        if (!update) return Result.fail("扣减失败！");
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单
        // 从当前线程获取用户 id
        UserDto user = UserHolder.getUser();
        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(user.getId());
        voucherOrder.setVoucherId(id);
        save(voucherOrder);
        return Result.ok("抢购成功！");
    }
```

### 3、一人一单

存在并发问题

<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>

启动类

@EnableAspectJAutoProxy(exposeProxy = true)
public class RedisDemoApplication

```java
    // 根据优惠卷 id 获取优惠卷
    @Override
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);

        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 从当前线程获取用户 id
        Long userId = UserHolder.getUser().getId();
        // 【一人一单】
        synchronized (userId.toString().intern()){
            // 【spring事务】失效问题
            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(id, userId);
        }
    }

    @Transactional
    public Result createVoucherOrder(Long id, Long userId) {
        // 【一人一单】
        Long count = query().eq("user_id", userId)
                .eq("voucher_id", id)
                .count();
        if (count > 0) return Result.fail("该用户已经下单！！");
        // 【版本号法】扣减优惠卷数量
        boolean update = voucherService.update()
                .setSql("stock = stock  - 1")
                .eq("id", id)
                // .eq("stock", stock) // 版本号法，失败了高
                .gt("stock",0) // stock > 0，实际业务，stock大于0就行
                .update();
        if (!update) return Result.fail("扣减失败！");
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单

        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(userId);
        voucherOrder.setVoucherId(id);
        save(voucherOrder);
        return Result.ok("抢购成功！");
    }
```

### 4、分布式系统

#### 1. 基于 redis 实现分布式锁初级版本（存在问题，解决见点3）

```java
package org.example.utils;

import org.springframework.data.redis.core.StringRedisTemplate;

import java.util.concurrent.TimeUnit;

public class RedisLock {
    
    private String keyName;
    private static final String KEY_PREFIX = "misxzaiz:lock:";
    private StringRedisTemplate stringRedisTemplate;
    
    public RedisLock(String keyName, StringRedisTemplate stringRedisTemplate) {
        this.keyName = keyName;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public boolean tryLock(long timeOutSec){
        String key = KEY_PREFIX + keyName;
        long threadId = Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, threadId + "", timeOutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    public void unlock(){
        stringRedisTemplate.delete(KEY_PREFIX + keyName);
    }
}
```

#### 2. 分布式

```java
    // 根据优惠卷 id 获取优惠卷
    @Override
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);

        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 从当前线程获取用户 id
        Long userId = UserHolder.getUser().getId();
        // 【分布式】
        RedisLock redisLock = new RedisLock("order:" + userId, stringRedisTemplate);
        boolean tryLock = redisLock.tryLock(5);
        if (!tryLock) return Result.fail("不允许重复请求！");
        try {
            // 【spring事务】失效问题
            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(id, userId);
        } finally {
            redisLock.unlock();
        }
    }
```

#### 3. 问题一

业务未完成，锁超时释放

在释放锁时，检查是否是同一个锁，线程id

不能直接使用线程id，分布式系统线程id可能相同

```java
package org.example.utils;

import cn.hutool.core.lang.UUID;
import org.springframework.data.redis.core.StringRedisTemplate;


import java.util.concurrent.TimeUnit;

public class RedisLock {

    private String keyName;
    private static final String KEY_PREFIX = "misxzaiz:lock:";
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    private StringRedisTemplate stringRedisTemplate;

    public RedisLock(String keyName, StringRedisTemplate stringRedisTemplate) {
        this.keyName = keyName;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public boolean tryLock(long timeOutSec){
        String key = KEY_PREFIX + keyName;
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, threadId, timeOutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    public void unlock(){
        // 获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 判断是否一致
        String s = stringRedisTemplate.opsForValue().get(KEY_PREFIX + keyName);
        if (threadId.equals(s)) {
            stringRedisTemplate.delete(KEY_PREFIX + keyName);
        }
    }
}

```

### 4、 分布式锁的原子性问题

在上面分布式锁中，判断锁标识和释放锁不是在同一个原子性操作中，因此可能会存在问题，这里可以使用 Lua 脚本功能；

在 Lua 脚本中可以编写多条 Redis 命令，确保多条命令执行时的原子性。

```lua
-- unlock.lua
-- 比较线程标识与锁标识是否一致
if(redis.call('get', KEYS[1]) == ARGV[1]) then
    -- 释放锁
    return redis.call('del', KEYS[1])
end
return 0
```

初始化脚本

```java
    private final StringRedisTemplate stringRedisTemplate;

    // lua 脚本
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }
```

调用 lua 脚本

```java
    public void unlock(){
        // 调用 Lua 脚本
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + keyName),
                ID_PREFIX + Thread.currentThread().getId());
    }
```

完整 RedisLock

```java
package org.example.utils;

import cn.hutool.core.lang.UUID;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;


import java.util.Collections;
import java.util.concurrent.TimeUnit;

public class RedisLock {

    private final String keyName;
    private static final String KEY_PREFIX = "misxzaiz:lock:";
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    private final StringRedisTemplate stringRedisTemplate;

    // lua 脚本
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

    public RedisLock(String keyName, StringRedisTemplate stringRedisTemplate) {
        this.keyName = keyName;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public boolean tryLock(long timeOutSec){
        String key = KEY_PREFIX + keyName;
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, threadId, timeOutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    public void unlock(){
        // 调用 Lua 脚本
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + keyName),
                ID_PREFIX + Thread.currentThread().getId());
    }
}

```

## 四、Redisson

官网：[Redisson: Easy Redis Java client with features of In-Memory Data Grid](https://redisson.org/)

Github：[Home · redisson/redisson Wiki (github.com)](https://github.com/redisson/redisson/wiki)

### 1、基于 setnx 实现的分布式锁存在的问题

问题：

- 不可重入：同一个线程无法多次获取同一把锁
- 不可重试：获取锁只尝试一次就返回 false，没有重试机制
- 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患
- 主从一致性：如果 Redis 提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，就会出现锁实现

### 2、Redisson

Redisson 是一个在 Redis 的基础上实现的 Java 驱内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。

### 3、分布式锁（Lock）和同步器（Synchronizer）

1. 可重入锁（Reentrant Lock）
2. 公平锁（Fair Lock）
3. 联锁（MultiLock）
4. 红锁（RedLock）
5. 读写锁（ReadWriteLock）
6. 信号量（Semaphore）
7. 可过期性信号量（PermitExpirableSemaphore）
8. 闭锁（CountDownLatch）

### 4、Redisson 入门

引入依赖：

```xml
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.13.6</version>
        </dependency>
```

配置 Redisson 客户端：

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedissonClient redissonClient(){
        // 配置类
        Config config = new Config();
        // 添加 Redis 地址，这里添加了单点的地址，也可以使用 config.useClusterServers() 添加集群地址
        config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword("1234");
        // 创建客户端
        return Redisson.create(config);
    }
}
```



