实现

- 超卖问题
- 一人一单

## 一、数据表


```sql
DROP TABLE IF EXISTS `tb_voucher`;
CREATE TABLE `tb_voucher`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `shop_id` bigint(20) UNSIGNED NULL DEFAULT NULL COMMENT '商铺id',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '代金券标题',
  `sub_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '副标题',
  `rules` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '使用规则',
  `stock` int UNSIGNED NOT NULL DEFAULT 0 COMMENT '优惠卷数量',
  `pay_value` bigint(10) UNSIGNED NOT NULL COMMENT '支付金额，单位是分。例如200代表2元',
  `actual_value` bigint(10) NOT NULL COMMENT '抵扣金额，单位是分。例如200代表2元',
  `type` tinyint(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '0,普通券；1,秒杀券',
  `status` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '1,上架; 2,下架; 3,过期',
  `start_time` timestamp NOT NULL COMMENT '创建时间',
  `end_time` timestamp NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

INSERT INTO `tb_voucher` VALUES (1, 1, '80元代金券', '周一至周日均可使用', '全场通用\\n无需预约\\n可无限叠加\\不兑现、不找零\\n仅限堂食', 100, 10000, 8000, 1, 1, '2022-06-24 09:42:39', '2025-06-25 09:42:39');

DROP TABLE IF EXISTS `tb_voucher_order`;
CREATE TABLE `tb_voucher_order`  (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `user_id` bigint(20) UNSIGNED NOT NULL COMMENT '下单的用户id',
  `voucher_id` bigint(20) UNSIGNED NOT NULL COMMENT '购买的代金券id',
  `pay_type` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '支付方式 1：余额支付；2：支付宝；3：微信',
  `status` tinyint(1) UNSIGNED NOT NULL DEFAULT 1 COMMENT '订单状态，1：未支付；2：已支付；3：已核销；4：已取消；5：退款中；6：已退款',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '下单时间',
  `pay_time` timestamp NULL DEFAULT NULL COMMENT '支付时间',
  `use_time` timestamp NULL DEFAULT NULL COMMENT '核销时间',
  `refund_time` timestamp NULL DEFAULT NULL COMMENT '退款时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;
```

## 二、实体类

### Voucher

```java
package org.example.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.util.Date;

@Data
@TableName("tb_voucher")
public class Voucher {
    private Long id;
    private Long shopId;
    private String title;
    private String subTitle;
    private String rules;
    private Integer stock;
    private Long payValue;
    private Long actualValue;
    private Integer type;
    private Integer status;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date startTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date endTime;
}
```

### VoucherOrder

```java
package org.example.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;

import java.util.Date;

@Data
@TableName("tb_voucher_order")
public class VoucherOrder {
    private Long id;
    private Long userId;
    private Long voucherId;
    private Integer payType;
    private Integer status;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date createTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date payTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date useTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date refundTime;
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")
    private Date updateTime;
}
```

## 三、抢购优惠卷

### 1、基本构成

1. 查询数据库
2. 检查是否在抢卷时间
3. 检查优惠卷数量是否充足
4. 扣减优惠卷数量
5. 保存优惠卷订单

```java
    @Override
    @Transactional
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);
        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 扣减优惠卷数量
        voucher.setStock(--stock);
        boolean updateMark = voucherService.updateById(voucher);
        if (!updateMark) return Result.fail("扣减失败！");
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单
        // 从当前线程获取用户 id
        UserDto user = UserHolder.getUser();
        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(user.getId());
        voucherOrder.setVoucherId(id);
        save(voucherOrder);
        return Result.ok("抢购成功！");
    }
```

### 2、超卖问题

版本号法：这里可以以库存为版本号

乐观锁：在更新时判断是否有其他线程在修改，存在成功率低问题

有些不能使用库存作为版本号，可能有一个人修改库存加一，然后又有一个人给库存减一，因此要以一个单独属性为版本号

```java
    @Override
    @Transactional
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);
        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 【版本号法】扣减优惠卷数量
        boolean update = voucherService.update()
                .setSql("stock = stock  - 1")
                .eq("id", id)
                // .eq("stock", stock) // 版本号法，失败了高
                .gt("stock",0) // stock > 0，实际业务，stock大于0就行
                .update();
        if (!update) return Result.fail("扣减失败！");
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单
        // 从当前线程获取用户 id
        UserDto user = UserHolder.getUser();
        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(user.getId());
        voucherOrder.setVoucherId(id);
        save(voucherOrder);
        return Result.ok("抢购成功！");
    }
```

### 3、一人一单

存在并发问题

<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>

启动类

@EnableAspectJAutoProxy(exposeProxy = true)
public class RedisDemoApplication

```java
    // 根据优惠卷 id 获取优惠卷
    @Override
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);

        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 从当前线程获取用户 id
        Long userId = UserHolder.getUser().getId();
        // 【一人一单】
        synchronized (userId.toString().intern()){
            // 【spring事务】失效问题
            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(id, userId);
        }
    }

    @Transactional
    public Result createVoucherOrder(Long id, Long userId) {
        // 【一人一单】
        Long count = query().eq("user_id", userId)
                .eq("voucher_id", id)
                .count();
        if (count > 0) return Result.fail("该用户已经下单！！");
        // 【版本号法】扣减优惠卷数量
        boolean update = voucherService.update()
                .setSql("stock = stock  - 1")
                .eq("id", id)
                // .eq("stock", stock) // 版本号法，失败了高
                .gt("stock",0) // stock > 0，实际业务，stock大于0就行
                .update();
        if (!update) return Result.fail("扣减失败！");
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单

        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(userId);
        voucherOrder.setVoucherId(id);
        save(voucherOrder);
        return Result.ok("抢购成功！");
    }
```

### 4、分布式系统

#### 1. 基于 redis 实现分布式锁初级版本（存在问题，解决见点3）

```java
package org.example.utils;

import org.springframework.data.redis.core.StringRedisTemplate;

import java.util.concurrent.TimeUnit;

public class RedisLock {
    
    private String keyName;
    private static final String KEY_PREFIX = "misxzaiz:lock:";
    private StringRedisTemplate stringRedisTemplate;
    
    public RedisLock(String keyName, StringRedisTemplate stringRedisTemplate) {
        this.keyName = keyName;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public boolean tryLock(long timeOutSec){
        String key = KEY_PREFIX + keyName;
        long threadId = Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, threadId + "", timeOutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    public void unlock(){
        stringRedisTemplate.delete(KEY_PREFIX + keyName);
    }
}
```

#### 2. 分布式

```java
    // 根据优惠卷 id 获取优惠卷
    @Override
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);

        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 从当前线程获取用户 id
        Long userId = UserHolder.getUser().getId();
        // 【分布式】
        RedisLock redisLock = new RedisLock("order:" + userId, stringRedisTemplate);
        boolean tryLock = redisLock.tryLock(5);
        if (!tryLock) return Result.fail("不允许重复请求！");
        try {
            // 【spring事务】失效问题
            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(id, userId);
        } finally {
            redisLock.unlock();
        }
    }
```

#### 3. 问题一

业务未完成，锁超时释放

在释放锁时，检查是否是同一个锁，线程id

不能直接使用线程id，分布式系统线程id可能相同

```java
package org.example.utils;

import cn.hutool.core.lang.UUID;
import org.springframework.data.redis.core.StringRedisTemplate;


import java.util.concurrent.TimeUnit;

public class RedisLock {

    private String keyName;
    private static final String KEY_PREFIX = "misxzaiz:lock:";
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    private StringRedisTemplate stringRedisTemplate;

    public RedisLock(String keyName, StringRedisTemplate stringRedisTemplate) {
        this.keyName = keyName;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public boolean tryLock(long timeOutSec){
        String key = KEY_PREFIX + keyName;
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, threadId, timeOutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    public void unlock(){
        // 获取线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 判断是否一致
        String s = stringRedisTemplate.opsForValue().get(KEY_PREFIX + keyName);
        if (threadId.equals(s)) {
            stringRedisTemplate.delete(KEY_PREFIX + keyName);
        }
    }
}

```

### 4、 分布式锁的原子性问题

在上面分布式锁中，判断锁标识和释放锁不是在同一个原子性操作中，因此可能会存在问题，这里可以使用 Lua 脚本功能；

在 Lua 脚本中可以编写多条 Redis 命令，确保多条命令执行时的原子性。

```lua
-- unlock.lua
-- 比较线程标识与锁标识是否一致
if(redis.call('get', KEYS[1]) == ARGV[1]) then
    -- 释放锁
    return redis.call('del', KEYS[1])
end
return 0
```

初始化脚本

```java
    private final StringRedisTemplate stringRedisTemplate;

    // lua 脚本
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }
```

调用 lua 脚本

```java
    public void unlock(){
        // 调用 Lua 脚本
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + keyName),
                ID_PREFIX + Thread.currentThread().getId());
    }
```

完整 RedisLock

```java
package org.example.utils;

import cn.hutool.core.lang.UUID;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;


import java.util.Collections;
import java.util.concurrent.TimeUnit;

public class RedisLock {

    private final String keyName;
    private static final String KEY_PREFIX = "misxzaiz:lock:";
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
    private final StringRedisTemplate stringRedisTemplate;

    // lua 脚本
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

    public RedisLock(String keyName, StringRedisTemplate stringRedisTemplate) {
        this.keyName = keyName;
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public boolean tryLock(long timeOutSec){
        String key = KEY_PREFIX + keyName;
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, threadId, timeOutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }

    public void unlock(){
        // 调用 Lua 脚本
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + keyName),
                ID_PREFIX + Thread.currentThread().getId());
    }
}

```

## 四、Redisson

官网：[Redisson: Easy Redis Java client with features of In-Memory Data Grid](https://redisson.org/)

Github：[Home · redisson/redisson Wiki (github.com)](https://github.com/redisson/redisson/wiki)

### 1、基于 setnx 实现的分布式锁存在的问题

问题：

- 不可重入：同一个线程无法多次获取同一把锁
- 不可重试：获取锁只尝试一次就返回 false，没有重试机制
- 超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患
- 主从一致性：如果 Redis 提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，就会出现锁实现

### 2、Redisson

Redisson 是一个在 Redis 的基础上实现的 Java 驱内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。

### 3、分布式锁（Lock）和同步器（Synchronizer）

1. 可重入锁（Reentrant Lock）
2. 公平锁（Fair Lock）
3. 联锁（MultiLock）
4. 红锁（RedLock）
5. 读写锁（ReadWriteLock）
6. 信号量（Semaphore）
7. 可过期性信号量（PermitExpirableSemaphore）
8. 闭锁（CountDownLatch）

### 4、Redisson 入门

引入依赖：

```xml
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.13.6</version>
        </dependency>
```

配置 Redisson 客户端：

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedissonClient redissonClient(){
        // 配置类
        Config config = new Config();
        // 添加 Redis 地址，这里添加了单点的地址，也可以使用 config.useClusterServers() 添加集群地址
        config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword("1234");
        // 创建客户端
        return Redisson.create(config);
    }
}
```

使用实例：

```java
package org.example;

import org.junit.jupiter.api.Test;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.TimeUnit;

@SpringBootTest
public class RedissonTest {

    @Autowired
    private RedissonClient redissonClient;

    @Test
    public void test() throws InterruptedException {
        // 获取锁（可重入），并指定锁的名称
        RLock myLock = redissonClient.getLock("myLock");
        // 尝试获取锁，参数分别是：获取锁的最大等待实践（期间会重试），锁自动释放时间，时间单位
        boolean isLock = myLock.tryLock(1, 10, TimeUnit.SECONDS);
        // 判断是否获取成功
        if (isLock) {
            try {
                System.out.println("执行业务！");
            } finally {
                myLock.unlock();
            }
        }
    }
}

```

### 5、使用 Redisson 保证一人一单

```java
    @Autowired
    private RedissonClient redissonClient;

    // 根据优惠卷 id 获取优惠卷
    @Override
    public Result getVoucherOrderById(Long id) {
        log.info("【优惠卷订单·getVoucherOrderById】id:{}",id);

        // 查询数据库，获取优惠卷
        Voucher voucher = voucherService.getById(id);
        // 检查是否在抢卷时间
        if ( !checkTime(voucher) ) return Result.fail("不在抢购时间内！");
        // 【版本号法】检查优惠卷数量是否充足
        Integer stock = voucher.getStock();
        if (voucher.getStock() < 1) return Result.fail("优惠卷数量不足！");
        // 从当前线程获取用户 id
        Long userId = UserHolder.getUser().getId();
        // 【Redisson】
        RLock tryLock = redissonClient.getLock("lock:order:" + userId);
        boolean isLock = false;
        try {
            isLock = tryLock.tryLock(1, 10, TimeUnit.SECONDS);
            if (!isLock) return Result.fail("不允许重复请求！");
            // 【spring事务】失效问题
            VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();
            return proxy.createVoucherOrder(id, userId);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            tryLock.unlock();
        }
    }
```

### 6、*联锁* multiLock

```java
package org.example.config;

import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RedisConfig {

    @Bean
    public RedissonClient redissonClient(){
        // 配置类
        Config config = new Config();
        // 添加 Redis 地址，这里添加了单点的地址，也可以使用 config.useClusterServers() 添加集群地址
        config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword("1234");
        // 创建客户端
        return Redisson.create(config);
    }

    @Bean
    public RedissonClient redissonClient1(){
        // 配置类
        Config config = new Config();
        // 添加 Redis 地址，这里添加了单点的地址，也可以使用 config.useClusterServers() 添加集群地址
        config.useSingleServer().setAddress("redis://127.0.0.1:6380");
        // 创建客户端
        return Redisson.create(config);
    }

    @Bean
    public RedissonClient redissonClient2(){
        // 配置类
        Config config = new Config();
        // 添加 Redis 地址，这里添加了单点的地址，也可以使用 config.useClusterServers() 添加集群地址
        config.useSingleServer().setAddress("redis://127.0.0.1:6381").setPassword("1234");
        // 创建客户端
        return Redisson.create(config);
    }
}

```

```java
package org.example;

import org.junit.jupiter.api.Test;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.TimeUnit;

@SpringBootTest
public class RedissonTest {

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private RedissonClient redissonClient1;

    @Autowired
    private RedissonClient redissonClient2;


    @Test
    public void test() throws InterruptedException {

        RLock myLock = redissonClient.getLock("myLock");
        RLock myLock1 = redissonClient1.getLock("myLock");
        RLock myLock2 = redissonClient2.getLock("myLock");
        // 创建联锁 multiLock
        RLock multiLock = redissonClient.getMultiLock(myLock, myLock1, myLock2);
        
        // 尝试获取锁，参数分别是：获取锁的最大等待实践（期间会重试），锁自动释放时间，时间单位
        boolean isLock = myLock.tryLock(1, 10, TimeUnit.SECONDS);
        // 判断是否获取成功
        if (isLock) {
            try {

                System.out.println("执行业务！");

            } finally {
                myLock.unlock();
            }
        }
    }
}

```

## 五、Redis 秒杀优化

基于阻塞队列的异步秒杀，提高性能

### 1、在 Redis 实现库存检测及一人一单判断

提高并发能力

#### 数据类型

- String 记录库存
- Set 集合保存下单用户（唯一性）

#### 流程（使用 lua 脚本保证原子性）

1. 判断库存是否充足
2. 判断用户是否下单
3. 扣减库存（Redis）
4. 将 UserId 存储到 Set 集合中
5. 返回 0 表示具有购买资格（1为库存不足、2为重复下单）

#### Lua

1. 执行 Lua 脚本
2. 判断是否为 0
3. 将优惠卷 id、订单 id、用户 id 存入阻塞队列
4. 返回订单 id

### 2、修改优惠卷数量（Mysql、Redis）

```java
@Slf4j
@RestController
@RequestMapping("/voucher")
public class VoucherController {

    @Autowired
    private VoucherService voucherService;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @GetMapping("/setVoucherCount/{count}")
    public Result setVoucherCount(@PathVariable Integer count){
        Long voucherId = 1L;
        // 修改优惠卷数量
        Voucher voucher = new Voucher();
        voucher.setId(voucherId);
        voucher.setStock(count);
        // 保存优惠卷数量到 mysql 中
        voucherService.updateById(voucher);
        // 保存优惠卷数量到 redis 中
        stringRedisTemplate.opsForValue().set("misxzaiz:voucher:stock:"+voucherId,count.toString());
        return Result.ok("修改成功！");
    }
}
```

### 3、Lua 脚本

```java
-- 1. 参数
-- 1.1 优惠卷 id
local voucherId = ARGV[1]
-- 1.2 用户 id
local userId = ARGV[2]

-- 2. 数据
-- 2.1 库存 key
local stockKey = 'misxzaiz:voucher:stock:' .. voucherId
-- 2.2 订单 key
local orderKey = 'misxzaiz:voucher:order:' .. voucherId

-- 3. 脚本业务
-- 3.1 判断库存是否充足 get stockKey
if(tonumber(redis.call('get',stockKey)) <= 0) then
    -- 3.2 库存不足，返回 1
    return 1
end
-- 3.3 判断用户是否下单
if(redis.call('sismember',orderKey,userId) == 1) then
    -- 3.4 存在，说明是重复下单，返回 2
    return 2
end
-- 3.5 扣减库存 incrby stockKey - 1
redis.call('incrby', stockKey, -1)
-- 3.6 下单（保存用户）sadd orderKey userId
redis.call('sadd', orderKey, userId)
-- 返回 0 表示成功
return 0
```

### 4、Java 代码

```java
package org.example.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.example.dto.Result;
import org.example.entity.Voucher;
import org.example.entity.VoucherOrder;
import org.example.mapper.VoucherOrderMapper;
import org.example.service.VoucherOrderService;
import org.example.service.VoucherService;
import org.example.utils.RedisIDWorker;
import org.example.utils.UserHolder;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.aop.framework.AopContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.PostConstruct;
import java.util.Collections;
import java.util.Date;
import java.util.concurrent.*;

@Slf4j
@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements VoucherOrderService {

    @Autowired
    private VoucherService voucherService;

    @Autowired
    private RedisIDWorker redisIDWorker;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    // lua 脚本
    private static final DefaultRedisScript<Long> VOUCHER_SCRIPT;
    static {
        VOUCHER_SCRIPT = new DefaultRedisScript<>();
        VOUCHER_SCRIPT.setLocation(new ClassPathResource("voucher.lua"));
        VOUCHER_SCRIPT.setResultType(Long.class);
    }

    // 阻塞队列
    private BlockingQueue<VoucherOrder> orderTasks = new ArrayBlockingQueue<>(1024 * 1024);
    // 宣线程池
    private static final ExecutorService VOUCHER_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();

    // 容器初始化后就执行
    @PostConstruct
    private void init(){
        VOUCHER_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }
    private class VoucherOrderHandler implements Runnable {
        @Override
        public void run() {
            // 不会不断循环导致CPU负载增加，会在orderTasks.take()等待
            while (true){
                try {
                    // 获取队列中的订单信息
                    VoucherOrder voucherOrder = orderTasks.take();
                    // 创建订单
                    handlerVoucherOrder(voucherOrder);
                } catch (Exception e) {
                    log.info("处理优惠卷订单异常！");
                }

            }
        }
    }

    private void handlerVoucherOrder(VoucherOrder voucherOrder) {
        Long userId = voucherOrder.getUserId();
        Long voucherId = voucherOrder.getVoucherId();
        // 【Redisson】
        RLock tryLock = redissonClient.getLock("lock:order:" + userId);
        boolean isLock = false;
        try {
            isLock = tryLock.tryLock(1, 10, TimeUnit.SECONDS);
            if (!isLock) {
                log.error("不允许重复下单！");
                return;
            }
            // 【spring事务】失效问题
            proxy.createVoucherOrder(voucherOrder);
            return;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            tryLock.unlock();
        }
    }

    // 代理对象
    private VoucherOrderService proxy;
    /**
     * 通过 lua 脚本获取优惠卷，异步下单，提高性能
     * @param id 优惠卷 id
     * @return
     */
    @Override
    public Result getVoucherOrderByIdWithLua(Long id) {
        Long userId = UserHolder.getUser().getId();
        // 执行 lua 脚本
        Long execute = stringRedisTemplate.execute(
                VOUCHER_SCRIPT,
                Collections.emptyList(),
                id.toString(), userId.toString());
        // 判断结果是否为 0(execute != null 是解决 Long 拆箱可能为 null 的空指针异常）
        if (execute != null && execute != 0) {
            return Result.fail(execute == 1 ?"库存不足！":"重复下单！");
        }
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 将下单信息保存到阻塞队列中
        VoucherOrder voucherOrder = new VoucherOrder();
        voucherOrder.setId(voucherOrderId);
        voucherOrder.setUserId(userId);
        voucherOrder.setVoucherId(id);
        // 创建阻塞队列
        orderTasks.add(voucherOrder);
        // 获取代理对象
        proxy = (VoucherOrderService) AopContext.currentProxy();
        return Result.ok(voucherOrderId);
    }


    @Transactional
    public void createVoucherOrder(VoucherOrder voucherOrder) {
        Long userId = voucherOrder.getUserId();
        Long voucherId = voucherOrder.getVoucherId();
        // 【一人一单】
        Long count = query().eq("user_id", userId)
                .eq("voucher_id", voucherId)
                .count();
        // 用户已经下单
        if (count > 0) return;
        // 【版本号法】扣减优惠卷数量
        boolean update = voucherService.update()
                .setSql("stock = stock  - 1")
                .eq("id", voucherId)
                // .eq("stock", stock) // 版本号法，失败了高
                .gt("stock",0) // stock > 0，实际业务，stock大于0就行
                .update();
        // 扣减失败
        if (!update);
        // 生成全局唯一id作为优惠卷订单号
        long voucherOrderId = redisIDWorker.nextId("order:voucher:");
        // 保存订单
        save(voucherOrder);
        return;
    }

    private static boolean checkTime(Voucher voucher) {
        // 检查是否在抢购时间
        Date now = new Date();
        return !now.before(voucher.getStartTime()) && !now.after(voucher.getEndTime());
    }
}

```

