# 常用基础类

## 一、包装类

基本数据类型：byte、short、int、long、float、double、char和boolean。

包装类：Byte、Short、Integer、Long、Float、Double、Character和Boolean。

特殊的包装类：Number和Object。

### 包装类和基本类型转换

将基本数据类型转换为包装类对象：

- 使用构造函数：例如，`Integer i = new Integer(10)` 将整数 10 转换为 Integer 对象。
- 使用 **valueOf()** 方法：例如，`Integer i = Integer.valueOf(10)` 也可以将整数 10 转换为 Integer 对象。

将包装类对象转换为基本数据类型：

- 使用 **xxxValue()** 方法：例如，`int i = integerObj.intValue()` 将 Integer 对象转换为 int 类型的基本数据类型。xxx 表示相应的基本数据类型，例如 intValue() 对应 int 类型。
- 使用自动拆箱（unboxing）功能：例如，`int i = integerObj` 也可以将 Integer 对象转换为 int 类型的基本数据类型。

### 重写Object()方法

#### equals()：

在Object()中，equals()和（==）都是比较地址的，在包装类中，equals()反映的是逻辑关系；

```java
  Object o1 = new Object();
  Object o2 = new Object();
  System.out.println(o1==o2); // false
  System.out.println(o1.equals(o2)); // false
  
  Integer i1 = 1;
  Integer i2 = 1;
  System.out.println(i1==i2); // true 因为i1和i2的值都是1，而Java在内部缓存了所有 int 值（范围从 -128 到127），因此i1和i2共享同一个整数对象。
  System.out.println(i1.equals(i2)); // true
  
  Integer i3 = 128;
  Integer i4 = 128;
  System.out.println(i3==i4); // false
  System.out.println(i3.equals(i4)); // true
```

#### hashCode()：

`hashCode()`是Java Object类中的一个方法，它返回对象的哈希码值（hash code），是一个整数。哈希码本质上是对对象在内存中地址的一个简单处理，通常可以用来快速查找对象。

根据Object类的默认实现，一个对象的哈希码是由它的内存地址计算而来的。因此，每个对象都有一个不同的哈希码值。如果两个对象调用了`equals()`方法并且返回true，那么它们的哈希码必须相同（但是反过来不一定成立）。

Java中的集合框架（如HashSet、HashMap等）使用哈希码来组织和检索对象，因此**如果我们在自定义类中重写了`equals()`方法，则还应该重写`hashCode()`方法**，以便让这些方法能够正常工作并符合预期的行为。

```java
        Object o1 = new Object();
        Object o2 = new Object();
        System.out.println(o1.hashCode()); // 1324119927（不定）
        System.out.println(o2.hashCode()); // 990368553（不定）

        Integer i1 = 1;
        Integer i2 = 128;
        System.out.println(i1.hashCode()); // 1
        System.out.println(i2.hashCode()); // 128
```

### valueOf()

包装类中的valueOf()方法是一个静态方法，**用于将字符串或基本数据类型转换为对应的包装类对象**。其语法如下：

```
public static 包装类 valueOf(参数)
```

其中，参数可以是一个字符串或一个基本数据类型的值，返回值是一个对应的包装类对象。

例如，Integer类中的valueOf()方法可以将一个字符串或int类型的值转换为Integer对象，示例代码如下：

```java
// 使用字符串创建一个Integer对象
Integer num1 = Integer.valueOf("123");

// 使用int类型的值创建一个Integer对象
int a = 456;
Integer num2 = Integer.valueOf(a);
```

需要注意的是，如果传入的字符串无法转换为对应的数值类型，则会抛出NumberFormatException异常；另外，valueOf()方法返回的是一个引用类型的对象，而不是一个基本数据类型的值。

### 实现Comparable接口

Java中的包装类（如Integer、Double等）实现了Comparable接口，这意味着它们可以被排序和比较。如果需要使用自定义对象进行排序或比较，也可以实现Comparable接口，并重写compareTo()方法。

下面是一个示例，演示如何在自定义类中实现Comparable接口：

```java
Codepublic class MyClass implements Comparable<MyClass> {
    private int id;
    private String name;

    // Constructor, getters and setters

    @Override
    public int compareTo(MyClass other) {
        return Integer.compare(this.id, other.id);
    }
}
```

在上面的代码示例中，我们让MyClass类实现了Comparable接口，并重写了compareTo()方法。在该方法中，我们比较了两个对象的id属性，以确定它们的相对顺序。这里我们使用了Java内置的静态方法`Integer.compare()`来比较整型的大小，但您也可以使用传统的比较方式来实现compareTo()方法。

通过使用实现Comparable接口的类，我们可以将类的对象放入像Collections.sort(List<T>)等需要排序的方法中，而不必实现Comparator接口。

Collections.sort()方法是一个非常方便的排序方法，它可以对实现了Comparable接口的类的对象进行排序。例如：

```java
CodeList<MyClass> list = new ArrayList<>();
list.add(new MyClass(3, "C"));
list.add(new MyClass(1, "A"));
list.add(new MyClass(2, "B"));

Collections.sort(list);

for (MyClass obj : list) {
    System.out.println(obj.getId() + ", " + obj.getName());
}
```

在上面的示例中，我们使用ArrayList来存储MyClass类型的对象，并通过调用Collections.sort()方法对它们进行排序。由于MyClass类实现了Comparable接口并重写了compareTo()方法，因此该类的对象可以被正确地排序。

实现Comparable接口的类需要保证compareTo()方法具有以下特性：

1. 自反性：对于任何非null引用x，x.compareTo(x)应该返回0。
2. 对称性：对于任何非null引用x和y，如果y.compareTo(x)返回值与x.compareTo(y)返回值相反，则这两个对象的比较结果应该是一致的。
3. 传递性：对于任何非null引用x、y和z，如果x.compareTo(y)返回值为正数且y.compareTo(z)返回值为正数，则x.compareTo(z)也应该返回正数。或者，如果x.compareTo(y)返回值为零且y.compareTo(z)返回值为零，则x.compareTo(z)也应该返回零。或者，如果x.compareTo(y)返回值为负数且y.compareTo(z)返回值为负数，则x.compareTo(z)也应该返回负数。
4. 兼容性：实现Comparable接口的类与Java平台上的所有排序方法（如Collections.sort()和Arrays.sort()）应该是兼容的。

注意，如果实现Comparable接口的类不满足以上条件，可能会导致排序过程中出现未定义的行为。因此，一定要仔细考虑compareTo()方法的实现，并在测试时验证它是否能够正确地工作。

### Number

Number是一个抽象类，它是所有数字包装类（Byte、Short、Integer、Long、Float和Double）的超类。Number类提供了一系列抽象方法，用于将基本数据类型转换为包装类对象或者从包装类对象中获取基本数据类型值。这些方法包括：

- byteValue()：返回此数值以byte类型表示的值
- shortValue()：返回此数值以short类型表示的值
- intValue()：返回此数值以int类型表示的值
- longValue()：返回此数值以long类型表示的值
- floatValue()：返回此数值以float类型表示的值
- doubleValue()：返回此数值以double类型表示的值

例如，可以使用Integer类创建一个整型数值，并通过Number类来获取该数值的不同类型表示，示例代码如下：

```java
Integer num = new Integer(123);
byte b = num.byteValue();      // 获取byte类型的值
short s = num.shortValue();    // 获取short类型的值
int i = num.intValue();        // 获取int类型的值
long l = num.longValue();      // 获取long类型的值
float f = num.floatValue();    // 获取float类型的值
double d = num.doubleValue();  // 获取double类型的值
```

需要注意的是，由于Number是一个抽象类，因此不能直接创建它的实例，只能通过其子类来创建对象。另外，在进行类型转换时，可能会发生精度损失或溢出等问题，需要特别注意。

## 二、String

## 三、StringBuilder

## 四、Arrays

## 五、日期和时间

## 六、随机

